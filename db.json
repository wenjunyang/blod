{"meta":{"version":1,"warehouse":"1.0.2"},"models":{"Asset":[{"_id":"themes/jacman/source/js/totop.js","path":"js/totop.js","modified":1},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","path":"js/jquery.imagesloaded.min.js","modified":1},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","path":"js/jquery-2.0.3.min.js","modified":1},{"_id":"themes/jacman/source/js/gallery.js","path":"js/gallery.js","modified":1},{"_id":"themes/jacman/source/img/scrollup.png","path":"img/scrollup.png","modified":1},{"_id":"themes/jacman/source/img/logo.svg","path":"img/logo.svg","modified":1},{"_id":"themes/jacman/source/img/logo.png","path":"img/logo.png","modified":1},{"_id":"themes/jacman/source/img/jacman.jpg","path":"img/jacman.jpg","modified":1},{"_id":"themes/jacman/source/img/favicon.ico","path":"img/favicon.ico","modified":1},{"_id":"themes/jacman/source/img/cc-zero.svg","path":"img/cc-zero.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by.svg","path":"img/cc-by.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-sa.svg","path":"img/cc-by-sa.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nd.svg","path":"img/cc-by-nd.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nc.svg","path":"img/cc-by-nc.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","path":"img/cc-by-nc-sa.svg","modified":1},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","path":"img/cc-by-nc-nd.svg","modified":1},{"_id":"themes/jacman/source/img/banner.jpg","path":"img/banner.jpg","modified":1},{"_id":"themes/jacman/source/img/author.jpg","path":"img/author.jpg","modified":1},{"_id":"themes/jacman/source/font/fontdiao.woff","path":"font/fontdiao.woff","modified":1},{"_id":"themes/jacman/source/font/fontdiao.ttf","path":"font/fontdiao.ttf","modified":1},{"_id":"themes/jacman/source/font/fontdiao.svg","path":"font/fontdiao.svg","modified":1},{"_id":"themes/jacman/source/font/fontdiao.eot","path":"font/fontdiao.eot","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","path":"font/fontawesome-webfont.woff","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","path":"font/fontawesome-webfont.ttf","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","path":"font/fontawesome-webfont.svg","modified":1},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","path":"font/fontawesome-webfont.eot","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","path":"font/coveredbyyourgrace-webfont.woff","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","path":"font/coveredbyyourgrace-webfont.ttf","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","path":"font/coveredbyyourgrace-webfont.svg","modified":1},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","path":"font/coveredbyyourgrace-webfont.eot","modified":1},{"_id":"themes/jacman/source/font/FontAwesome.otf","path":"font/FontAwesome.otf","modified":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1},{"_id":"themes/jacman/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1},{"_id":"themes/jacman/source/css/style.styl","path":"css/style.styl","modified":1},{"_id":"source/images/perceptron.gif","path":"images/perceptron.gif","modified":1},{"_id":"source/images/myself.jpg","path":"images/myself.jpg","modified":1},{"_id":"source/images/math_exam.jpg","path":"images/math_exam.jpg","modified":1},{"_id":"source/images/kaggle_first.png","path":"images/kaggle_first.png","modified":1},{"_id":"source/images/happy.jpg","path":"images/happy.jpg","modified":1},{"_id":"source/images/duality_perceptron.gif","path":"images/duality_perceptron.gif","modified":1},{"_id":"source/CNAME","path":"CNAME","modified":1}],"Cache":[{"_id":"source/404.html","shasum":"ba318b20396509fab7513b99cb6adb0c95a39924","modified":1430653400160},{"_id":"source/CNAME","shasum":"de95ba56333a41778e1c5c56e64331b1d3a4f338","modified":1430650696207},{"_id":"source/_posts/hive-udf使用.md","shasum":"a5bf9bc569f5101e07b8b17122d753b5638c4351","modified":1448976586808},{"_id":"source/_posts/kaggle-digit-recognizer之PCA+KNN解法.md","shasum":"438fcad4f015a258be6620b31487ba46e857f4e7","modified":1447419093589},{"_id":"source/_posts/k近邻法-统计学习方法笔记（二）.md","shasum":"9fe07e2c62170dad18b4c58709e8439ea39ed9cc","modified":1446730782344},{"_id":"source/_posts/几道笔试题.md","shasum":"8c0f5a883aa5645265744bdf101b10f79cfad617","modified":1446210154996},{"_id":"source/_posts/kaggle-digit-recognizer之naive-bayes解法.md","shasum":"e6e1970d667432144c1b0b2192ded8d1d9ed5868","modified":1447419093591},{"_id":"source/_posts/kaggle-digit-recognizer之logistic-regression解法.md","shasum":"f9e1f201bb978ed9d4be10d18bd07c5da0f9a4e9","modified":1447419093590},{"_id":"source/_posts/单链表O(1)插入删除.md","shasum":"edde230f31b91b67726df37cecadcdb8206ae814","modified":1443090366215},{"_id":"source/_posts/字符串相关的若干算法.md","shasum":"079185b7dd9257b3ef8175f6da6e0b7e574e64fa","modified":1449323221121},{"_id":"source/_posts/种子.md","shasum":"889ff37fab7636f13c295204a0cd91296f28a4da","modified":1461515985414},{"_id":"source/_posts/优先级矩阵求表达式的值.md","shasum":"99d50b08b0e0ef9da35b991998c8ca4abb44fdf6","modified":1448976586809},{"_id":"source/about/index.md","shasum":"4abdb6e2786001003db6cbcd4bf8e9abc84adb90","modified":1430751946500},{"_id":"source/_posts/随机从数组中抽取多个元素.md","shasum":"241d332c1a750be36f0bfb99630f2951bf771a1e","modified":1443090377266},{"_id":"source/_posts/感知机模型-统计学习方法笔记（一）.md","shasum":"33f4b36030a63e75a3be9ee5d4e048acd11f8c13","modified":1446209907386},{"_id":"source/images/kaggle_first.png","shasum":"3517b74def9a8dfdb59b4e8bfda2dc9635dfc84c","modified":1442405343011},{"_id":"source/images/math_exam.jpg","shasum":"4d9a401d6377bc5a2366eaba8363c2fd9dbe1457","modified":1458298846439},{"_id":"source/_posts/利用netcat快速搭建http服务.md","shasum":"76ee49c0fb53e92fcdfd617650ab823c8d02a17f","modified":1447419093591},{"_id":"source/temp/一点也不开心.md","shasum":"25e4a70de748ee6cf0245b380aa0524d3e18ac2c","modified":1461668544750},{"_id":"source/temp/可怜的桃子.md","shasum":"bff54199f2bff1e675c77d27509fcf7eedd845e5","modified":1461669504767},{"_id":"source/temp/断线的风筝.md","shasum":"e6fa25e11314b56250d07d179d2273b977f5f851","modified":1461667799483},{"_id":"source/temp/近期学习计划.md","shasum":"2b6f1596e4abcaeeabcb9143a0aa353020e49c56","modified":1447941842163},{"_id":"source/temp/一道小学数学题.md","shasum":"c857d66363b5a7f854dfcaaba04f9762e7931267","modified":1460174731575},{"_id":"source/images/happy.jpg","shasum":"ba461bb77480f440d28089cde5e65721561c5d2a","modified":1442502930713},{"_id":"source/images/perceptron.gif","shasum":"7629ff8d37b60203e16f0501301b47d32248a699","modified":1446209836068},{"_id":"source/images/duality_perceptron.gif","shasum":"10e722651d286615ccb72a7d124d66a27b124181","modified":1446209860600},{"_id":"themes/jacman/LICENSE","shasum":"d8780b41bab4b87bdd21eca444cae11af72617f4","modified":1430648098161},{"_id":"themes/jacman/dot_git/FETCH_HEAD","shasum":"6df7cfbd4d37ad6fa1b88ad6dde0f7358a06cb83","modified":1443091358382},{"_id":"themes/jacman/dot_git/HEAD","shasum":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1430648098150},{"_id":"themes/jacman/dot_git/ORIG_HEAD","shasum":"6afad8a6f409cb823e445991e2f596d12c812b21","modified":1443091358550},{"_id":"themes/jacman/dot_git/config","shasum":"b3a21db5b179edac7874b32200ec23ede61361fe","modified":1430648098154},{"_id":"themes/jacman/README.md","shasum":"ea52694ca940f7a8c0d9f9be0d653904dbe53819","modified":1430648098161},{"_id":"themes/jacman/dot_git/description","shasum":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1430648008301},{"_id":"themes/jacman/README_zh.md","shasum":"8cc4fc09bae6bb7a77f5405cca53c1581c39279d","modified":1430648098162},{"_id":"themes/jacman/_config.yml","shasum":"3d267abaa1a6637b97de3f99dfbdaa7b4984c61a","modified":1458303218955},{"_id":"themes/jacman/dot_git/hooks/post-update.sample","shasum":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1430648008303},{"_id":"themes/jacman/dot_git/hooks/applypatch-msg.sample","shasum":"86b9655a9ebbde13ac8dd5795eb4d5b539edab0f","modified":1430648008302},{"_id":"themes/jacman/dot_git/hooks/pre-applypatch.sample","shasum":"42fa41564917b44183a50c4d94bb03e1768ddad8","modified":1430648008303},{"_id":"themes/jacman/dot_git/hooks/commit-msg.sample","shasum":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1430648008302},{"_id":"themes/jacman/dot_git/hooks/pre-commit.sample","shasum":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1430648008303},{"_id":"themes/jacman/dot_git/hooks/pre-push.sample","shasum":"b4ad74c989616b7395dc6c9fce9871bb1e86dfb5","modified":1430648008303},{"_id":"themes/jacman/dot_git/hooks/pre-rebase.sample","shasum":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1430648008304},{"_id":"themes/jacman/dot_git/info/exclude","shasum":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1430648008305},{"_id":"themes/jacman/dot_git/logs/HEAD","shasum":"5cb951c997c880f89005c0a87fb60e46857b6e10","modified":1430648098152},{"_id":"themes/jacman/dot_git/logs/refs/heads/master","shasum":"5cb951c997c880f89005c0a87fb60e46857b6e10","modified":1430648098152},{"_id":"themes/jacman/dot_git/logs/refs/remotes/origin/HEAD","shasum":"5cb951c997c880f89005c0a87fb60e46857b6e10","modified":1430648098150},{"_id":"themes/jacman/dot_git/logs/refs/remotes/origin/master","shasum":"41041c8a3dd468392c738e71d4525325b7053714","modified":1443091358381},{"_id":"themes/jacman/dot_git/objects/02/d4738f4cab860846fc4ef9a3ce5d2ada78365c","shasum":"aa5df943bcc48ed117e3d33708091ffcfb61e80a","modified":1443091358351},{"_id":"themes/jacman/dot_git/hooks/prepare-commit-msg.sample","shasum":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1430648008304},{"_id":"themes/jacman/dot_git/hooks/update.sample","shasum":"39355a075977d05708ef74e1b66d09a36e486df1","modified":1430648008304},{"_id":"themes/jacman/dot_git/objects/18/2dfffbd110f2e62503d19b243a8bea18ffe3d1","shasum":"b9bc3783f54b1749682ee73dd88db3fd1bd6b954","modified":1443091358348},{"_id":"themes/jacman/dot_git/objects/1a/17618708a15ad5c9518315e30ac64036fd92f0","shasum":"833336bae198eecfaed623ea8d3499cebb1a242f","modified":1443091358317},{"_id":"themes/jacman/dot_git/objects/21/cbc2be751fc61ff7f42140ae56fb6c09ecc4f8","shasum":"ff89057c42754664f5e685817c4579ffcf019aa7","modified":1443091358315},{"_id":"themes/jacman/dot_git/objects/2c/e1a1a3c49ab38770e28c46aa6dff4439c92a88","shasum":"2bdfc1316e6a12ce5a464c883f46d050121ed565","modified":1443091358295},{"_id":"themes/jacman/dot_git/objects/33/4a86a9aee55dec9b29ed318cd19c6917f3b082","shasum":"0c34a27f254f1bf459f4d9488012530e6559534c","modified":1443091358333},{"_id":"themes/jacman/dot_git/objects/35/47a63765d2726c26daaf8f3d59a682bcc50c19","shasum":"0a59537282a410c5ac6e9671dfbb9c54a1386f9c","modified":1443091358334},{"_id":"themes/jacman/dot_git/objects/46/5ac7ca2ac88fa0f0f9303421b7bcf0019f4caf","shasum":"30c1fedc2284ad5e6c160956881145f249e740a5","modified":1443091358347},{"_id":"themes/jacman/dot_git/objects/62/d864246ec1d78ff8c83d81621acd4fcd9d3502","shasum":"3ddda01d1fa1b9813bd794398eea56bfe2940901","modified":1443091358314},{"_id":"themes/jacman/dot_git/objects/64/ed711225ad68a619af590b3a7f5b78a1d3498f","shasum":"f28321be52dd53f86ba94cc6f798eb6f373c7623","modified":1443091358357},{"_id":"themes/jacman/dot_git/objects/67/a3c2c5caa18b06d7ae3450c6836dcb7a9a447c","shasum":"e123c1addb64250a7074cd4eccb864a36592f8ea","modified":1443091358318},{"_id":"themes/jacman/dot_git/objects/6b/288df316f9ebffbf98d43512e2964cb603c13e","shasum":"a4177af3265c20ec1f77c3a3fe716dce660eb509","modified":1443091358324},{"_id":"themes/jacman/dot_git/index","shasum":"62b85650b99a6a4f4dc6e9a3420792c50302bd15","modified":1442105492163},{"_id":"themes/jacman/dot_git/objects/15/3db3b2dbb55e90774669fd4b387b7071f74fe0","shasum":"e5436b1d01ceb1a2bb0f0592599183060719940b","modified":1443091358355},{"_id":"themes/jacman/dot_git/objects/6c/98cc91b1fe874ed41558d538f063a01ca6c365","shasum":"f735bd04539b856bdde9ea995a7db4a8d5e68e9e","modified":1443091358326},{"_id":"themes/jacman/dot_git/objects/7a/1c39fb4e8fe87c3f8e52c3bf02a2386fe820e1","shasum":"5892a2ce05041b39c0559fafa3367074a36187be","modified":1443091358323},{"_id":"themes/jacman/dot_git/objects/7a/d4a409bda57996fc7bda1488b01310847e7d1b","shasum":"8568bd7a59d27b086828c42945a552ae75d52997","modified":1443091358327},{"_id":"themes/jacman/dot_git/objects/79/2da7b52082c1f760f84a610206f436b1b28249","shasum":"2d7c2676adc0f5fdfd4390acad589b131a4f0290","modified":1443091358354},{"_id":"themes/jacman/dot_git/objects/89/c1157a828f3188c192cbb74449eebd425dd24b","shasum":"7602c4aee7463af79b96deda5d76f664af610681","modified":1443091358350},{"_id":"themes/jacman/dot_git/objects/81/dd1b35f6a8a279490a04217e54fc7c57671f04","shasum":"1197396f5297393a3db2c8fcb8b0358bd6b1822e","modified":1443091358351},{"_id":"themes/jacman/dot_git/objects/93/5425d497b66821606606c1903ce92468b8496a","shasum":"f7ff83631c1b059b81714a5e899d78ff2503ceb4","modified":1443091358352},{"_id":"themes/jacman/dot_git/objects/96/64b12b3a7b0331702e682adeaf976914a269b6","shasum":"f26b795a2baac58cd339125bd3f63c9a70457737","modified":1443091358335},{"_id":"themes/jacman/dot_git/objects/97/60437dadabb48a084aef59b6394689844aa882","shasum":"143c5f7ca9a3931bcbb4ccbfd9819d8c04e96c1f","modified":1443091358349},{"_id":"themes/jacman/dot_git/objects/a1/42b89e2ba325f6f89d110c625ea8af0468132d","shasum":"19ee05da3addf405b01b0c2f5de68e7cfb2f9155","modified":1443091358331},{"_id":"themes/jacman/dot_git/objects/a3/eee1e5498662ed852892e4790e634af34e420b","shasum":"ce03e7bd14fdc6262550013b39519da7ca79f926","modified":1443091358322},{"_id":"themes/jacman/dot_git/objects/a8/1ba96d2aa7a0a0efea795ef637fad8d2b35734","shasum":"40d51f14af0fe0e2d96ad9b881a53f767e10650b","modified":1443091358334},{"_id":"themes/jacman/dot_git/objects/b6/52e827b6859c19d5bf141981ef022f808d44a6","shasum":"1171145d62c422575b55fc8870257e2d534faf5c","modified":1443091358330},{"_id":"themes/jacman/dot_git/objects/be/c357a38308e5d247dd76e1cdd309135e332ae1","shasum":"8d148f0860fd629caa73a86da384ad901dab398e","modified":1443091358353},{"_id":"themes/jacman/dot_git/objects/d8/55a007a3b41c83e0353d036e2c51f89c459163","shasum":"01167e6e399dfde1fcc6ecc9e6c5c23af92d177f","modified":1443091358321},{"_id":"themes/jacman/dot_git/objects/f4/9e6c3109d00f8fcedc6eafa61b5e013e6706fd","shasum":"843826d8b0fe482329f64e28cc83fdd742ff2d99","modified":1443091358349},{"_id":"themes/jacman/dot_git/objects/fa/5567b86c8bbb613fb56cd592fc74015ecc0fa2","shasum":"a094b944530bd0f5f14e623211aec08c8f6835de","modified":1443091358330},{"_id":"themes/jacman/dot_git/objects/14/66536a6b0bb3befd180838d5165f7bfbce3799","shasum":"d434c12c2cae385c47d7e832adb2197cab46ba87","modified":1443091358327},{"_id":"themes/jacman/dot_git/objects/fe/0e84d595dd8617a3636af90c6de818c6a510de","shasum":"1c9b5dde61ee7ba2c09ae78146c075e20a9bc831","modified":1443091358353},{"_id":"themes/jacman/dot_git/objects/bd/99752edb095e284bdb725d7829406ff3c3b1c2","shasum":"72e34c52560fc622493ca98e7e54da8d041b5ad8","modified":1443091358332},{"_id":"themes/jacman/dot_git/objects/6f/f17fc2fa2cb1720af522b769144d4a5506b33d","shasum":"07a73c8f2a8325910e26db71121fbf1823bd2d76","modified":1443091358356},{"_id":"themes/jacman/dot_git/packed-refs","shasum":"0048ab467c39266e1773bab788e85ab03f0ff24e","modified":1430648098148},{"_id":"themes/jacman/dot_git/refs/heads/master","shasum":"6afad8a6f409cb823e445991e2f596d12c812b21","modified":1430648098152},{"_id":"themes/jacman/dot_git/refs/remotes/origin/HEAD","shasum":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1430648098149},{"_id":"themes/jacman/dot_git/refs/remotes/origin/master","shasum":"d147e572d7152656810b3f1669498b592518a51e","modified":1443091358374},{"_id":"themes/jacman/languages/default.yml","shasum":"32efe172560cf8a50884d5d5237d654fb59f7df4","modified":1430648098162},{"_id":"themes/jacman/languages/zh-CN.yml","shasum":"afe99ffe436eabea1b6476e8dbd87c0797609afb","modified":1430648098162},{"_id":"themes/jacman/languages/zh-TW.yml","shasum":"7b83cc0450a68fc8b9d723ecc37d831a0c18c6ea","modified":1430648098163},{"_id":"themes/jacman/layout/_partial/after_footer.ejs","shasum":"aa3d9860612888c6f86d6fccb688cafd82c28f16","modified":1431255774494},{"_id":"themes/jacman/layout/_partial/analytics.ejs","shasum":"5cb06f9d23b92815ff77766b894421e1037505f8","modified":1430648098163},{"_id":"themes/jacman/layout/_partial/archive.ejs","shasum":"90502fc2f5b0a5681a6c6588a9ed6ad297e32890","modified":1430648098163},{"_id":"themes/jacman/layout/_partial/article.ejs","shasum":"00c00b4a961ac1f7bc8ee688ce134fe0c454edc6","modified":1430648098163},{"_id":"themes/jacman/layout/_partial/article_row.ejs","shasum":"2c1f1edfeaebaafe4265d58e0b8110e71673da40","modified":1430648098164},{"_id":"themes/jacman/layout/_partial/categories.ejs","shasum":"2b77ff6cbc8571cab27c3bdc4ad51a79510bbca2","modified":1430648098164},{"_id":"themes/jacman/layout/_partial/footer.ejs","shasum":"b97f94b13b545af19e3b381732d4a37e91368ef8","modified":1430648098164},{"_id":"themes/jacman/dot_git/objects/pack/pack-6b7fa01f571a30bc215e63ff5860951f67bb13f1.idx","shasum":"cfd8fc96a2d89193a8b146aef2cfbe21e713f1db","modified":1430648098129},{"_id":"themes/jacman/dot_git/objects/fd/c46425bdc96b693177c0fc0c4302d4a2e1937b","shasum":"e2ef50d09fd763535d4bb58a8b0116fc38046c7d","modified":1443091358329},{"_id":"themes/jacman/layout/_partial/pagination.ejs","shasum":"6cf37f844f150af4bbe212610da61e5140317de9","modified":1430648098165},{"_id":"themes/jacman/layout/_partial/head.ejs","shasum":"210bb4c1ec77d998dfd93baeb4e3a0b46a925cd1","modified":1430648098164},{"_id":"themes/jacman/layout/_partial/post/catetags.ejs","shasum":"20349dcde9942885d5eae1c302ef26b1b8484f3f","modified":1430648098165},{"_id":"themes/jacman/layout/_partial/header.ejs","shasum":"795435cc84c46a18e4ac597435a81f66eb86b0c4","modified":1430648098165},{"_id":"themes/jacman/layout/_partial/post/comment.ejs","shasum":"9db7847461cf8b10a9cd5434deb690c6b26af6f1","modified":1430648098165},{"_id":"themes/jacman/layout/_partial/post/gallery.ejs","shasum":"fc23ef9b5a412e05436f68ff47146b860d2d4225","modified":1430648098166},{"_id":"themes/jacman/layout/_partial/mathjax.ejs","shasum":"5636df1f2b6a8d02986d866e3824ec60430046e6","modified":1430648098165},{"_id":"themes/jacman/layout/_partial/post/article.ejs","shasum":"c01220f0af629f9e23bf125bdc1beef8afc206ef","modified":1430648098165},{"_id":"themes/jacman/layout/_partial/post/footer.ejs","shasum":"5b9f5ee6a2cc8bd557550bbdc1a03d237681114e","modified":1430648098166},{"_id":"themes/jacman/layout/_partial/post/header.ejs","shasum":"351e771b1b38244560fc52cf60d91263d3d63eef","modified":1430648098166},{"_id":"themes/jacman/layout/_partial/sidebar.ejs","shasum":"846d96ff73409b9a8b34f3cab691821096c03e1d","modified":1430648098167},{"_id":"themes/jacman/layout/_partial/tags.ejs","shasum":"c5c858742b29e6364da2e1d098e7d6cd8cef038f","modified":1430648098167},{"_id":"themes/jacman/layout/_partial/post/jiathis.ejs","shasum":"12b7360326691ebf06bea5d7ee4d54c41f64e2ec","modified":1430648098166},{"_id":"themes/jacman/layout/_partial/tinysou_search.ejs","shasum":"67a55a4d94cca2db11a2636f1f2c92c208688b14","modified":1430648098167},{"_id":"themes/jacman/layout/_partial/totop.ejs","shasum":"224d078ba1f2c33c52d5e867af71c5fe9f1bdf45","modified":1430648098167},{"_id":"themes/jacman/layout/_widget/archive.ejs","shasum":"b82d7fb0d1119738a9f9bb747d415e8c99e454ae","modified":1430648098168},{"_id":"themes/jacman/layout/_widget/category.ejs","shasum":"2c1b9ac7666d7d5b9aaf8f33588e10451c4b7841","modified":1430648098168},{"_id":"themes/jacman/layout/_widget/douban.ejs","shasum":"e0b545c996fac814885861a01113387ad8469ac2","modified":1430648098168},{"_id":"themes/jacman/layout/_widget/links.ejs","shasum":"bd73be669ddc47e1daab38736d1cecc3f37662e2","modified":1430648098168},{"_id":"themes/jacman/layout/_widget/tag.ejs","shasum":"43b1c29fea51f849ec0bf85a6d91fe0507f01503","modified":1430648098168},{"_id":"themes/jacman/layout/_widget/rss.ejs","shasum":"ebfb11bdd603cd6e4dcf3949cc52e38009615c25","modified":1430648098168},{"_id":"themes/jacman/layout/_widget/tagcloud.ejs","shasum":"317d420f5448c7452290e37f0ed8516cb73f4068","modified":1430648098169},{"_id":"themes/jacman/layout/_widget/weibo.ejs","shasum":"94830c333cbef9da84266416b8d55d3a7dfddf0e","modified":1431843004623},{"_id":"themes/jacman/layout/archive.ejs","shasum":"a18842e3d719fe3ca9b977a6995f8facc75c8673","modified":1430648098169},{"_id":"themes/jacman/layout/category.ejs","shasum":"9b740fc33f6f028df60f0bc4312bf3ebd03aa8ea","modified":1430648098169},{"_id":"themes/jacman/layout/index.ejs","shasum":"b832b280ec0a2b741e73a2300f219f0075c99278","modified":1430648098169},{"_id":"themes/jacman/layout/page.ejs","shasum":"bd6bbf2ea8e183bd835867ff617dc6366b56748c","modified":1430648098170},{"_id":"themes/jacman/layout/_partial/search.ejs","shasum":"732fcd909f6dac557629206dc7e93a7083cda084","modified":1430648098167},{"_id":"themes/jacman/layout/post.ejs","shasum":"3114134775bdde5a83cf14feb019606fa2b2b2be","modified":1430648098170},{"_id":"themes/jacman/layout/_partial/post/pagination.ejs","shasum":"091512e19cfcf5bde2a699b211f99874f26587ad","modified":1430648098166},{"_id":"themes/jacman/scripts/fancybox.js","shasum":"4c130fc242cf9b59b5df6ca5eae3b14302311e8c","modified":1430648098170},{"_id":"themes/jacman/layout/tag.ejs","shasum":"45150a2365768b6b67880193c9264ad2bb4814db","modified":1430648098170},{"_id":"themes/jacman/source/css/_base/code.styl","shasum":"0eb8825710b573f3f444c4c90933211bfe531078","modified":1430648098171},{"_id":"themes/jacman/source/css/_base/font.styl","shasum":"5699c270be7b28c5b2c36f453317ccd42789fd3d","modified":1430648098171},{"_id":"themes/jacman/source/css/_base/public.styl","shasum":"657ad4c267490bd3b9ac98b5f864ecddb7025586","modified":1430648098171},{"_id":"themes/jacman/layout/layout.ejs","shasum":"ceeb2a7410b96b81310ed9b1279f62e953b0a6ca","modified":1430648098169},{"_id":"themes/jacman/source/css/_base/variable.styl","shasum":"0b7d517e12102a99be82bc1a9104bb6bfd4ca10b","modified":1430648098171},{"_id":"themes/jacman/source/css/_partial/duoshuo.styl","shasum":"3ec423b734639614fbd11ec2c3445d3a03f5231d","modified":1430648098172},{"_id":"themes/jacman/source/css/_partial/footer.styl","shasum":"0300d7d289eceb3933c1eebf38f8d10f425c1128","modified":1430648098173},{"_id":"themes/jacman/source/css/_partial/gallery.styl","shasum":"75843d727319b1d07ad4b8c2e969036ce0d4f362","modified":1430648098173},{"_id":"themes/jacman/source/css/_partial/header.styl","shasum":"f1ae52a4f41d4cfdd66cb186b0329af904fead4f","modified":1430648098173},{"_id":"themes/jacman/source/css/_partial/helper.styl","shasum":"bdf04e4b4521a80e883173a77be0ff772277a4a1","modified":1430648098173},{"_id":"themes/jacman/source/css/_partial/index.styl","shasum":"d5a3046587f42703224ac3b761e80baab35d4ccc","modified":1430648098173},{"_id":"themes/jacman/source/css/style.styl","shasum":"98019eb8d70618259928c3472f9b17568848c794","modified":1430648098174},{"_id":"themes/jacman/source/fancybox/blank.gif","shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1430648098174},{"_id":"themes/jacman/source/css/_partial/totop.styl","shasum":"b48360e757d501027b7dbe093859d03795476930","modified":1430648098173},{"_id":"themes/jacman/source/fancybox/fancybox_loading.gif","shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1430648098174},{"_id":"themes/jacman/source/css/_partial/article.styl","shasum":"0bcb684376fcbf4be42d1df5dd02c395760f7ffb","modified":1430648098172},{"_id":"themes/jacman/source/css/_partial/aside.styl","shasum":"6c303908a7af7234ba032ef9e1189b68ae492f22","modified":1430648098172},{"_id":"themes/jacman/source/fancybox/fancybox_overlay.png","shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1430648098175},{"_id":"themes/jacman/source/fancybox/helpers/fancybox_buttons.png","shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1430648098175},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.css","shasum":"6394c48092085788a8c0ef72670b0652006231a1","modified":1430648098175},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-buttons.js","shasum":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1430648098176},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-media.js","shasum":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1430648098176},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.css","shasum":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1430648098176},{"_id":"themes/jacman/source/fancybox/helpers/jquery.fancybox-thumbs.js","shasum":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1430648098176},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.css","shasum":"2e54d51d21e68ebc4bb870f6e57d3bfb660d4f9c","modified":1430648098177},{"_id":"themes/jacman/source/fancybox/fancybox_sprite.png","shasum":"17df19f97628e77be09c352bf27425faea248251","modified":1430648098175},{"_id":"themes/jacman/source/fancybox/fancybox_sprite@2x.png","shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1430648098175},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.pack.js","shasum":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1430648098178},{"_id":"themes/jacman/source/font/FontAwesome.otf","shasum":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1430648098179},{"_id":"themes/jacman/source/fancybox/fancybox_loading@2x.gif","shasum":"273b123496a42ba45c3416adb027cd99745058b0","modified":1430648098174},{"_id":"themes/jacman/source/fancybox/jquery.fancybox.js","shasum":"58193c802f307ec9bc9e586c0e8a13ebef45d2f8","modified":1430648098177},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.eot","shasum":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1430648098179},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.ttf","shasum":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1430648098181},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.woff","shasum":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1430648098182},{"_id":"themes/jacman/source/font/fontawesome-webfont.eot","shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1430648098182},{"_id":"themes/jacman/source/font/fontdiao.woff","shasum":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f","modified":1430648098188},{"_id":"themes/jacman/source/font/fontawesome-webfont.woff","shasum":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1430648098185},{"_id":"themes/jacman/source/font/fontdiao.eot","shasum":"9544a0d7ba208989302bc4da5a184faeb0e883c9","modified":1430648098186},{"_id":"themes/jacman/source/font/fontdiao.ttf","shasum":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab","modified":1430648098188},{"_id":"themes/jacman/source/img/cc-by-nc-nd.svg","shasum":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1430648098191},{"_id":"themes/jacman/source/img/cc-by-nc-sa.svg","shasum":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1430648098191},{"_id":"themes/jacman/source/img/cc-by-nc.svg","shasum":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1430648098191},{"_id":"themes/jacman/source/img/cc-by-nd.svg","shasum":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1430648098192},{"_id":"themes/jacman/source/img/favicon.ico","shasum":"2d22a3e0c7905a894e832c831dd91c29c209c7a5","modified":1430648098192},{"_id":"themes/jacman/source/img/jacman.jpg","shasum":"0ba14a4a5e3be012826fc713c33479912126d34e","modified":1430648098193},{"_id":"themes/jacman/source/img/cc-by-sa.svg","shasum":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1430648098192},{"_id":"themes/jacman/source/img/cc-by.svg","shasum":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1430648098192},{"_id":"themes/jacman/source/img/scrollup.png","shasum":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1430648098193},{"_id":"themes/jacman/source/img/cc-zero.svg","shasum":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1430648098192},{"_id":"themes/jacman/source/img/logo.svg","shasum":"85aa31ebe543572b4f9debd6c5f99271d89b5f30","modified":1430648098193},{"_id":"themes/jacman/source/js/gallery.js","shasum":"735a714e54f0ac229f292a90df3a1f882904f6c7","modified":1430648098194},{"_id":"themes/jacman/source/js/jquery.imagesloaded.min.js","shasum":"28ef4346743a60c896a9ae492a544c0854904350","modified":1430648098195},{"_id":"themes/jacman/source/font/coveredbyyourgrace-webfont.svg","shasum":"739808e56a56e10a03bc93d03eb55abd19590942","modified":1430648098180},{"_id":"themes/jacman/source/font/fontawesome-webfont.ttf","shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1430648098185},{"_id":"themes/jacman/source/font/fontdiao.svg","shasum":"50e0247e9d39756843b7e4f720503b37bfb6154b","modified":1430648098187},{"_id":"themes/jacman/source/img/author.jpg","shasum":"5723811f9f1773e320047605404e396c55e4fc4d","modified":1452007715859},{"_id":"themes/jacman/source/js/totop.js","shasum":"48648ec9c86e9ab491831e5a029e6f8864934149","modified":1430648098195},{"_id":"themes/jacman/source/img/logo.png","shasum":"fd08d12d1fa147cf894e8f8327e38f1758de32ed","modified":1430648098193},{"_id":"themes/jacman/source/js/jquery-2.0.3.min.js","shasum":"cd981db035ec1b6f502fca78fd394c5bd438aba1","modified":1430648098194},{"_id":"themes/jacman/source/font/fontawesome-webfont.svg","shasum":"a275426daefd3716c53561fad121d258a7f05b47","modified":1430648098184},{"_id":"themes/jacman/source/img/banner.jpg","shasum":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74","modified":1430648098190},{"_id":"themes/jacman/dot_git/objects/pack/pack-6b7fa01f571a30bc215e63ff5860951f67bb13f1.pack","shasum":"4882791d70915ff92655a543e074814c1408a83d","modified":1430648098133},{"_id":"source/images/myself.jpg","shasum":"4b560bdb0af301967ff8d29eb29d16467876f04f","modified":1460174391534},{"_id":"public/js/totop.js","modified":1467736258417,"shasum":"cad23c5ea7163d1e5c05a0fd3ef9233469da10cb"},{"_id":"public/js/jquery.imagesloaded.min.js","modified":1467736258423,"shasum":"4109837b1f6477bacc6b095a863b1b95b1b3693f"},{"_id":"public/js/jquery-2.0.3.min.js","modified":1467736258427,"shasum":"a0ae3697b0ab8c0e8bd3186c80db42abd6d97a8d"},{"_id":"public/js/gallery.js","modified":1467736258430,"shasum":"f8a4ba7fb8349cca374a3c69fff9b2bf21f742ed"},{"_id":"public/img/scrollup.png","modified":1467736258489,"shasum":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3"},{"_id":"public/img/logo.svg","modified":1467736258494,"shasum":"85aa31ebe543572b4f9debd6c5f99271d89b5f30"},{"_id":"public/img/logo.png","modified":1467736258497,"shasum":"fd08d12d1fa147cf894e8f8327e38f1758de32ed"},{"_id":"public/img/jacman.jpg","modified":1467736258499,"shasum":"0ba14a4a5e3be012826fc713c33479912126d34e"},{"_id":"public/img/favicon.ico","modified":1467736258504,"shasum":"2d22a3e0c7905a894e832c831dd91c29c209c7a5"},{"_id":"public/img/cc-zero.svg","modified":1467736258508,"shasum":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d"},{"_id":"public/img/cc-by.svg","modified":1467736258511,"shasum":"e92a33c32d1dac8ed94849b2b4e6456e887efe70"},{"_id":"public/img/cc-by-sa.svg","modified":1467736258513,"shasum":"70c1535f43e54e5ff35ca81419e77e4c0c301398"},{"_id":"public/img/cc-by-nd.svg","modified":1467736258515,"shasum":"42cd73da328077ccc92f859bb8f3cf621b3484f8"},{"_id":"public/img/cc-by-nc.svg","modified":1467736258519,"shasum":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab"},{"_id":"public/img/cc-by-nc-sa.svg","modified":1467736258523,"shasum":"6f55543d1fb9cbc436c101d24f802dec7b41efc3"},{"_id":"public/img/cc-by-nc-nd.svg","modified":1467736258534,"shasum":"bc3588c9b2d7c68830524783120ff6cf957cf668"},{"_id":"public/img/banner.jpg","modified":1467736258537,"shasum":"5104860c4f8b2e84ef734ba6c37fe7a288bf0d74"},{"_id":"public/img/author.jpg","modified":1467736258540,"shasum":"5723811f9f1773e320047605404e396c55e4fc4d"},{"_id":"public/font/fontdiao.woff","modified":1467736258543,"shasum":"71f54eb6e98aa28cafeb04aab71c0e5b349ea89f"},{"_id":"public/font/fontdiao.ttf","modified":1467736258545,"shasum":"ee9fd7be2493c9bf6d2841044e69a0830d9d3fab"},{"_id":"public/font/fontdiao.svg","modified":1467736258547,"shasum":"50e0247e9d39756843b7e4f720503b37bfb6154b"},{"_id":"public/font/fontdiao.eot","modified":1467736258549,"shasum":"9544a0d7ba208989302bc4da5a184faeb0e883c9"},{"_id":"public/font/fontawesome-webfont.woff","modified":1467736258552,"shasum":"04c3bf56d87a0828935bd6b4aee859995f321693"},{"_id":"public/font/fontawesome-webfont.ttf","modified":1467736258554,"shasum":"7f09c97f333917034ad08fa7295e916c9f72fd3f"},{"_id":"public/font/fontawesome-webfont.svg","modified":1467736258556,"shasum":"a275426daefd3716c53561fad121d258a7f05b47"},{"_id":"public/font/fontawesome-webfont.eot","modified":1467736258559,"shasum":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e"},{"_id":"public/font/coveredbyyourgrace-webfont.woff","modified":1467736258561,"shasum":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e"},{"_id":"public/font/coveredbyyourgrace-webfont.ttf","modified":1467736258564,"shasum":"194ccb4acf77a03dc25bcc174edb266143704fec"},{"_id":"public/font/coveredbyyourgrace-webfont.svg","modified":1467736258567,"shasum":"739808e56a56e10a03bc93d03eb55abd19590942"},{"_id":"public/font/coveredbyyourgrace-webfont.eot","modified":1467736258569,"shasum":"a17d0f10534303e40f210c506ebb8703fa23b7de"},{"_id":"public/font/FontAwesome.otf","modified":1467736258571,"shasum":"b5b4f9be85f91f10799e87a083da1d050f842734"},{"_id":"public/fancybox/jquery.fancybox.pack.js","modified":1467736258573,"shasum":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e"},{"_id":"public/fancybox/jquery.fancybox.js","modified":1467736258575,"shasum":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed"},{"_id":"public/fancybox/jquery.fancybox.css","modified":1467736258579,"shasum":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","modified":1467736258582,"shasum":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c"},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","modified":1467736258585,"shasum":"4ac329c16a5277592fc12a37cca3d72ca4ec292f"},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","modified":1467736258587,"shasum":"294420f9ff20f4e3584d212b0c262a00a96ecdb3"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","modified":1467736258589,"shasum":"dc3645529a4bf72983a39fa34c1eb9146e082019"},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","modified":1467736258591,"shasum":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8"},{"_id":"public/fancybox/helpers/fancybox_buttons.png","modified":1467736258594,"shasum":"e385b139516c6813dcd64b8fc431c364ceafe5f3"},{"_id":"public/fancybox/fancybox_sprite@2x.png","modified":1467736258595,"shasum":"30c58913f327e28f466a00f4c1ac8001b560aed8"},{"_id":"public/fancybox/fancybox_sprite.png","modified":1467736258597,"shasum":"17df19f97628e77be09c352bf27425faea248251"},{"_id":"public/fancybox/fancybox_overlay.png","modified":1467736258599,"shasum":"b3a4ee645ba494f52840ef8412015ba0f465dbe0"},{"_id":"public/fancybox/fancybox_loading@2x.gif","modified":1467736258601,"shasum":"273b123496a42ba45c3416adb027cd99745058b0"},{"_id":"public/fancybox/fancybox_loading.gif","modified":1467736258603,"shasum":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c"},{"_id":"public/fancybox/blank.gif","modified":1467736258605,"shasum":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a"},{"_id":"public/css/style.css","modified":1467736259461,"shasum":"d2eee82a731151e12d94b52aca10ff6d64da41da"},{"_id":"public/images/perceptron.gif","modified":1467736259739,"shasum":"7629ff8d37b60203e16f0501301b47d32248a699"},{"_id":"public/images/myself.jpg","modified":1467736259769,"shasum":"4b560bdb0af301967ff8d29eb29d16467876f04f"},{"_id":"public/images/math_exam.jpg","modified":1467736259783,"shasum":"4d9a401d6377bc5a2366eaba8363c2fd9dbe1457"},{"_id":"public/images/kaggle_first.png","modified":1467736259786,"shasum":"3517b74def9a8dfdb59b4e8bfda2dc9635dfc84c"},{"_id":"public/images/happy.jpg","modified":1467736259788,"shasum":"ba461bb77480f440d28089cde5e65721561c5d2a"},{"_id":"public/images/duality_perceptron.gif","modified":1467736259791,"shasum":"10e722651d286615ccb72a7d124d66a27b124181"},{"_id":"public/CNAME","modified":1467736259793,"shasum":"de95ba56333a41778e1c5c56e64331b1d3a4f338"},{"_id":"public/404.html","modified":1467736259812,"shasum":"0ae792adec33f8e5dd4687ef7767cdcc1da1e9b3"},{"_id":"public/temp/近期学习计划.html","modified":1467736259837,"shasum":"cc2a26e52b36f952af17406a44926b130b6f1abf"},{"_id":"public/temp/断线的风筝.html","modified":1467736259845,"shasum":"439a1955a2a450a749538a014054223bb9f40ec6"},{"_id":"public/temp/可怜的桃子.html","modified":1467736259861,"shasum":"3ef7615df02a45d924c7934d037f6100eb22105e"},{"_id":"public/temp/一道小学数学题.html","modified":1467736259885,"shasum":"985ad3b368f1bcb037b8a32b09fcf33f7b97e962"},{"_id":"public/temp/一点也不开心.html","modified":1467736259895,"shasum":"16c093700f9ab4941246712a6b0272c286c7b34a"},{"_id":"public/about/index.html","modified":1467736259903,"shasum":"748b052054beb2159aa97768786a9789e6d4d30c"},{"_id":"public/2016/04/24/种子/index.html","modified":1467736259916,"shasum":"ee7685b1af38552ebf0f586b0117b249d2758096"},{"_id":"public/2015/12/05/字符串相关的若干算法/index.html","modified":1467736259932,"shasum":"5e77aa43ebbc8af539836b1d929790dd5d243bc6"},{"_id":"public/2015/12/01/优先级矩阵求表达式的值/index.html","modified":1467736259962,"shasum":"fe739e89984cb9f125eb3cc94d3d73879b6f1935"},{"_id":"public/2015/11/11/利用netcat快速搭建http服务/index.html","modified":1467736259982,"shasum":"e2a4e2e24ad6e315f560ba3566dca69a54a4cde8"},{"_id":"public/2015/11/05/k近邻法-统计学习方法笔记（二）/index.html","modified":1467736260000,"shasum":"4b3bcd41e9ffdcfa62a6e3a1e877491ad61bca80"},{"_id":"public/2015/10/30/几道笔试题/index.html","modified":1467736260019,"shasum":"f01675ad8a98705f3afe85d5bcdedfb0e1ccabf4"},{"_id":"public/2015/10/30/感知机模型-统计学习方法笔记（一）/index.html","modified":1467736260038,"shasum":"794370ffe08a37f399b916d14a8abc2fefd3bf4b"},{"_id":"public/2015/09/28/kaggle-digit-recognizer之naive-bayes解法/index.html","modified":1467736260052,"shasum":"6eaf56bce4618c0bca001af3c3d127324ad696e2"},{"_id":"public/2015/09/24/hive-udf使用/index.html","modified":1467736260070,"shasum":"26af2654634349d1ddcd8594a4ae67a261cd01d6"},{"_id":"public/2015/09/23/kaggle-digit-recognizer之logistic-regression解法/index.html","modified":1467736260091,"shasum":"4400944cef62024b6934a9e67850fff949a4d37b"},{"_id":"public/2015/09/16/kaggle-digit-recognizer之PCA+KNN解法/index.html","modified":1467736260109,"shasum":"904e635feb527e429b4c2def73e77a76ddcb7a4c"},{"_id":"public/2015/05/10/随机从数组中抽取多个元素/index.html","modified":1467736260122,"shasum":"8b6e714e366605cd3769fd700da552d284504cc7"},{"_id":"public/2015/05/10/单链表O(1)插入删除/index.html","modified":1467736260139,"shasum":"d5a71120cd9e4e6d798576f5ddb6844293663293"},{"_id":"public/archives/index.html","modified":1467736260172,"shasum":"f149f7c04422c22222cb252ccb9ced3657c52b62"},{"_id":"public/archives/page/2/index.html","modified":1467736260180,"shasum":"99ec6f7d6fc5f94797c8a0ccb445b1c8163a083c"},{"_id":"public/archives/2015/index.html","modified":1467736260191,"shasum":"1aafcdf54e96092603532741c3cbb802215aff76"},{"_id":"public/archives/2015/page/2/index.html","modified":1467736260207,"shasum":"041054275a1cd69a011f0cd62b15b27e45678f65"},{"_id":"public/archives/2015/05/index.html","modified":1467736260215,"shasum":"1e0351f0d05869713ab8748e6eb2a2aaecfb174b"},{"_id":"public/archives/2015/09/index.html","modified":1467736260225,"shasum":"ec16e7790821622a8a501d6a6b7627c87a3e9809"},{"_id":"public/archives/2015/10/index.html","modified":1467736260232,"shasum":"7366d219a5c486729a5845016ba7184a22ed9508"},{"_id":"public/archives/2015/11/index.html","modified":1467736260243,"shasum":"33220815c2157fc0b4b1d6460608b4add44f28d4"},{"_id":"public/archives/2015/12/index.html","modified":1467736260250,"shasum":"78838e94be49a1f58a97c90da467603fb99f9ed1"},{"_id":"public/archives/2016/index.html","modified":1467736260258,"shasum":"6a7a197db5e1823535898aab735c49f13749642b"},{"_id":"public/archives/2016/04/index.html","modified":1467736260267,"shasum":"59023141ea5e4f5f339805b7feda9eb787b15792"},{"_id":"public/tags/笔试题/index.html","modified":1467736260273,"shasum":"bdc9a2b3e38c260ffa64c154810b15c971eb9fd2"},{"_id":"public/tags/机器学习/index.html","modified":1467736260280,"shasum":"7121120b10d6701e212809f75807e68aaf856998"},{"_id":"public/tags/算法/index.html","modified":1467736260287,"shasum":"3dcf080170571ba5a19d7be1596f701c6d1cd9c1"},{"_id":"public/tags/linux/index.html","modified":1467736260296,"shasum":"8babb3e220dd41ac03240b1129e5a7918cd31093"},{"_id":"public/tags/kaggle/index.html","modified":1467736260303,"shasum":"d2e1ca342ab965d89c304f30d5e9f2266adf9859"},{"_id":"public/tags/hive/index.html","modified":1467736260308,"shasum":"6c76b63900d756b0edb989a9dc420bcdaef0323e"},{"_id":"public/index.html","modified":1467736260334,"shasum":"13214f876dfee612ca3962f943c0b625d5aa1114"},{"_id":"public/page/2/index.html","modified":1467736260345,"shasum":"02adc88dd922ab13a7e6afb5d765a9bf1d3925d3"}],"Category":[],"Data":[],"Page":[{"_content":"<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n<!-- <meta http-equiv=\"Content-Type\" content=\"text/html; charset=gbk\" />  -->\n<html>\n\t<head><title>迷路了</title></head>\n\t<body>\n\t\t<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"http://wendale.cn/\" homePageName=\"回家吧\"/>\n\t</body>\n</html>","source":"404.html","raw":"<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n<!-- <meta http-equiv=\"Content-Type\" content=\"text/html; charset=gbk\" />  -->\n<html>\n\t<head><title>迷路了</title></head>\n\t<body>\n\t\t<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homePageUrl=\"http://wendale.cn/\" homePageName=\"回家吧\"/>\n\t</body>\n</html>","date":"2015-05-17T04:55:22.519Z","updated":"2015-05-03T11:43:20.160Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"ciq9o9r570000tor25817b6cv"},{"title":"近期学习计划","date":"2015-11-19T13:56:13.000Z","tags":null,"_content":"最近统计学习看了前半部分，做天池的比赛觉得还是无从下手，被第一步特征筛选及处理给难住了。这就是理论和实践的差距吧。整理了下近期要学的知识，以免有时会不知所措。\n1. 天池比赛，学习使用scikit-learn及御膳房的机器学习平台。\n2. 学习一个nosql数据库，会基本使用，了解原理。\n3. 参与一个开源项目。\n4. 经常总结，写博客，质量再提高点。","source":"temp/近期学习计划.md","raw":"title: \"近期学习计划\"\ndate: 2015-11-19 21:56:13\ntags:\n---\n最近统计学习看了前半部分，做天池的比赛觉得还是无从下手，被第一步特征筛选及处理给难住了。这就是理论和实践的差距吧。整理了下近期要学的知识，以免有时会不知所措。\n1. 天池比赛，学习使用scikit-learn及御膳房的机器学习平台。\n2. 学习一个nosql数据库，会基本使用，了解原理。\n3. 参与一个开源项目。\n4. 经常总结，写博客，质量再提高点。","updated":"2015-11-19T14:04:02.163Z","path":"temp/近期学习计划.html","comments":1,"layout":"page","_id":"ciq9o9r5b0001tor2znrnhszm"},{"title":"断线的风筝","date":"2016-03-29T15:37:52.000Z","tags":null,"_content":"本是风和日丽\n风筝在半空愉悦地飞\n风渐渐加大\n线被拉断\n从此\n一个扶摇而上\n一个坠落土壤","source":"temp/断线的风筝.md","raw":"title: \"断线的风筝\"\ndate: 2016-03-29 23:37:52\ntags:\n---\n本是风和日丽\n风筝在半空愉悦地飞\n风渐渐加大\n线被拉断\n从此\n一个扶摇而上\n一个坠落土壤","updated":"2016-04-26T10:49:59.483Z","path":"temp/断线的风筝.html","comments":1,"layout":"page","_id":"ciq9o9r5d0002tor2sknypuuh"},{"title":"可怜的桃子","date":"2016-04-26T11:18:24.000Z","tags":null,"_content":"","source":"temp/可怜的桃子.md","raw":"title: \"可怜的桃子\"\ndate: 2016-04-26 19:18:24\ntags:\n---\n","updated":"2016-04-26T11:18:24.767Z","path":"temp/可怜的桃子.html","comments":1,"layout":"page","_id":"ciq9o9r5e0003tor2gk7ygkxp"},{"title":"一道小学数学题","date":"2016-03-18T10:55:55.000Z","tags":null,"_content":"\n#解今天看到的香港小学数学题\n\n![](/images/math_exam.jpg)\n\n```\n\n# 之前写过的求全排列下一个升序排列\ndef next_permutation(permutation):\n    for i in range(len(permutation) - 1, 0, -1):\n        if permutation[i] > permutation[i-1]:\n            min_index = i\n            for j in range(i, len(permutation)):\n                if permutation[i-1] < permutation[j] < permutation[min_index]:\n                    min_index = j\n            permutation[i-1], permutation[min_index] = permutation[min_index], permutation[i-1]\n            m = i\n            n = len(permutation) - 1\n            while m < n:\n                permutation[m], permutation[n] = permutation[n], permutation[m]\n                m += 1\n                n -= 1\n            return permutation\n    return []\n\n\n# 枚举所有可能性，即10个数选9个的全排列\ndef all_prob():\n    for i in range(0, 10):\n        first = range(0, 10)\n        del first[i]\n        while (first):\n            yield first\n            first = next_permutation(first)\n\nif __name__ == '__main__':\n    for p in all_prob():\n        d = dict(zip(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'P'], p))\n        res1 = d['A'] * 10 + d['B'] - d['C'] * 10 - d['D']\n        res2 = res1 + d['G'] * 10 + d['H']\n        if res1 == d['E'] * 10 + d['F'] and res2 == 111 * d['P']\\\n                and d['A'] * d['C'] * d['E'] * d['G'] * d['P'] != 0:\n            print(d)\n\n```\n\n##结果如下：\n\n```\n{'A': 8, 'C': 4, 'B': 5, 'E': 3, 'D': 6, 'G': 7, 'F': 9, 'H': 2, 'P': 1}\n{'A': 8, 'C': 5, 'B': 6, 'E': 3, 'D': 4, 'G': 7, 'F': 2, 'H': 9, 'P': 1}\n{'A': 9, 'C': 2, 'B': 5, 'E': 6, 'D': 7, 'G': 4, 'F': 8, 'H': 3, 'P': 1}\n{'A': 9, 'C': 2, 'B': 0, 'E': 6, 'D': 7, 'G': 4, 'F': 3, 'H': 8, 'P': 1}\n{'A': 9, 'C': 6, 'B': 0, 'E': 2, 'D': 3, 'G': 8, 'F': 7, 'H': 4, 'P': 1}\n```\n\n##后记\n今天发现python的itertools库提供了丰富的排列组合工具，all_prob函数可以用itertools.permutations(range(0, 10), 9)代替。","source":"temp/一道小学数学题.md","raw":"title: \"一道小学数学题\"\ndate: 2016-03-18 18:55:55\ntags:\n---\n\n#解今天看到的香港小学数学题\n\n![](/images/math_exam.jpg)\n\n```\n\n# 之前写过的求全排列下一个升序排列\ndef next_permutation(permutation):\n    for i in range(len(permutation) - 1, 0, -1):\n        if permutation[i] > permutation[i-1]:\n            min_index = i\n            for j in range(i, len(permutation)):\n                if permutation[i-1] < permutation[j] < permutation[min_index]:\n                    min_index = j\n            permutation[i-1], permutation[min_index] = permutation[min_index], permutation[i-1]\n            m = i\n            n = len(permutation) - 1\n            while m < n:\n                permutation[m], permutation[n] = permutation[n], permutation[m]\n                m += 1\n                n -= 1\n            return permutation\n    return []\n\n\n# 枚举所有可能性，即10个数选9个的全排列\ndef all_prob():\n    for i in range(0, 10):\n        first = range(0, 10)\n        del first[i]\n        while (first):\n            yield first\n            first = next_permutation(first)\n\nif __name__ == '__main__':\n    for p in all_prob():\n        d = dict(zip(['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'P'], p))\n        res1 = d['A'] * 10 + d['B'] - d['C'] * 10 - d['D']\n        res2 = res1 + d['G'] * 10 + d['H']\n        if res1 == d['E'] * 10 + d['F'] and res2 == 111 * d['P']\\\n                and d['A'] * d['C'] * d['E'] * d['G'] * d['P'] != 0:\n            print(d)\n\n```\n\n##结果如下：\n\n```\n{'A': 8, 'C': 4, 'B': 5, 'E': 3, 'D': 6, 'G': 7, 'F': 9, 'H': 2, 'P': 1}\n{'A': 8, 'C': 5, 'B': 6, 'E': 3, 'D': 4, 'G': 7, 'F': 2, 'H': 9, 'P': 1}\n{'A': 9, 'C': 2, 'B': 5, 'E': 6, 'D': 7, 'G': 4, 'F': 8, 'H': 3, 'P': 1}\n{'A': 9, 'C': 2, 'B': 0, 'E': 6, 'D': 7, 'G': 4, 'F': 3, 'H': 8, 'P': 1}\n{'A': 9, 'C': 6, 'B': 0, 'E': 2, 'D': 3, 'G': 8, 'F': 7, 'H': 4, 'P': 1}\n```\n\n##后记\n今天发现python的itertools库提供了丰富的排列组合工具，all_prob函数可以用itertools.permutations(range(0, 10), 9)代替。","updated":"2016-04-09T04:05:31.575Z","path":"temp/一道小学数学题.html","comments":1,"layout":"page","_id":"ciq9o9r5f0004tor2fcfq2ma6"},{"title":"一点也不开心","date":"2016-04-26T10:48:08.000Z","tags":null,"_content":"\n哦，期待已久的涨薪\n哦，鸟语花香的清晨\n哦，温暖柔和的太阳\n哦，不期而来的奖金\n可是\n不见你灿烂的笑容\n我一点也不开心\n","source":"temp/一点也不开心.md","raw":"title: \"一点也不开心\"\ndate: 2016-04-26 18:48:08\ntags:\n---\n\n哦，期待已久的涨薪\n哦，鸟语花香的清晨\n哦，温暖柔和的太阳\n哦，不期而来的奖金\n可是\n不见你灿烂的笑容\n我一点也不开心\n","updated":"2016-04-26T11:02:24.750Z","path":"temp/一点也不开心.html","comments":1,"layout":"page","_id":"ciq9o9r5p0005tor29spw4es6"},{"title":"about","date":"2015-05-03T13:59:14.000Z","_content":"\n> wendale是一个菜鸟！","source":"about/index.md","raw":"title: \"about\"\ndate: 2015-05-03 21:59:14\n---\n\n> wendale是一个菜鸟！","updated":"2015-05-04T15:05:46.500Z","path":"about/index.html","comments":1,"layout":"page","_id":"ciq9o9r5r0006tor2r3d96mqe"}],"Post":[{"title":"随机从数组中抽取多个元素","date":"2015-05-10T06:27:04.000Z","_content":"\n> 如何优雅地随机抽取呢？\n\n```\n\t/**\n\t * 随机生成一个[0, n-1]的数\n\t */\n\tint rand_index(int n) {\n\t    srand(time(NULL));\n\t    return rand() % n;\n\t}\n\t/**\n\t * 问题描述：从数组array中随机抽取extract_num个元素，组成新的数组返回。\n\t *\n\t */\n\tint* random_extract(int array[], int array_num, int extract_num) {\n\t\n\t    int* result = (int*)malloc(extract_num * sizeof(int));\n\t\n\t    for (int i = 0; i < extract_num; ++i) {\n\t        int tmp = array[array_num - 1 - i];\n\t        int index = rand_index(array_num - 1 - i);\n\t        array[array_num - 1 - i] = array[index];\n\t        array[index] = tmp;\n\t        result[i] = tmp;\n\t    }\n\t\n\t    return result;\n\t}\n```","source":"_posts/随机从数组中抽取多个元素.md","raw":"title: \"随机从数组中抽取多个元素\"\ndate: 2015-05-10 14:27:04\ntags: 笔试题\n---\n\n> 如何优雅地随机抽取呢？\n\n```\n\t/**\n\t * 随机生成一个[0, n-1]的数\n\t */\n\tint rand_index(int n) {\n\t    srand(time(NULL));\n\t    return rand() % n;\n\t}\n\t/**\n\t * 问题描述：从数组array中随机抽取extract_num个元素，组成新的数组返回。\n\t *\n\t */\n\tint* random_extract(int array[], int array_num, int extract_num) {\n\t\n\t    int* result = (int*)malloc(extract_num * sizeof(int));\n\t\n\t    for (int i = 0; i < extract_num; ++i) {\n\t        int tmp = array[array_num - 1 - i];\n\t        int index = rand_index(array_num - 1 - i);\n\t        array[array_num - 1 - i] = array[index];\n\t        array[index] = tmp;\n\t        result[i] = tmp;\n\t    }\n\t\n\t    return result;\n\t}\n```","slug":"随机从数组中抽取多个元素","published":1,"updated":"2015-09-24T10:26:17.266Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq9o9r5t0007tor2664msty6"},{"title":"种子","date":"2016-04-24T15:06:06.000Z","_content":"暮春\n种子终于要重新破土而出\n虽若隐若现\n却毅力顽强\n只是，我期盼的\n并不是参天大树or绚彩夺目\n是深深扎根于土壤，万千丛林中的一株灌木\n纵享春夏\n笑看秋冬\n","source":"_posts/种子.md","raw":"title: \"种子\"\ndate: 2016-04-24 23:06:06\ntags:\n---\n暮春\n种子终于要重新破土而出\n虽若隐若现\n却毅力顽强\n只是，我期盼的\n并不是参天大树or绚彩夺目\n是深深扎根于土壤，万千丛林中的一株灌木\n纵享春夏\n笑看秋冬\n","slug":"种子","published":1,"updated":"2016-04-24T16:39:45.414Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq9o9r60000ator29l5gh9rp"},{"title":"感知机模型--统计学习方法笔记（一）","date":"2015-10-30T12:35:23.000Z","_content":"通过kaggle的练习，了解了几个分类算法，但是对于算法的原理还不理解。经过推荐，了解了李航的《统计学习方法》，感觉不错。书内容不多，全书主要讲了几种常见的分类算法。内容整体上比较容易理解。最近正好在学习python，python的numpy包在矩阵计算方面也很不错，matplotlib提供类丰富的绘图功能。可以通过matplotlib绘制gif图，这样可以把算法很生动地表现出来。争取以后每章做一篇读书笔记，笔记主要是代码、gif图像以及个人的心得。\n本节对应原书第二章。\n\n##原始形式\n```\nimport copy\n\nimport draw\n\nHISTORY = []\nTRAINS = [[(3, 3), 1], [(4, 3), 1], [(1, 1), -1]]\n\ndef update(w, b, item):\n    for i in range(len(item[0])):\n        w[i] += item[1] * item[0][i]\n    b += item[1]\n    return w, b\n    \ndef cal(item):\n    res = 0\n    for i in range(len(item[0])):\n        res += item[0][i] * w[i]\n    res += b\n    res *= item[1]\n    return res\n    \ndef iterComp(w, b, trains):\n    global HISTORY     \n    flag = False\n    for item in trains:\n        if cal(item) <= 0:\n            flag = True\n            (w, b) = update(w, b, item)\n            HISTORY.append([copy.copy(w), b])\n    if not flag:\n        print \"RESULT:w:\" + str(w) + \"b:\" + str(b)\n    return flag, w, b\n    \nif __name__ == \"__main__\":\n    w = [0, 0]\n    b = 0   \n    while True:\n        (flag, w, b) = iterComp(w, b, TRAINS)\n        if not flag:\n            break\n    draw.show(TRAINS, HISTORY, True, 'result/perceptron.gif')\n```\n得到如下结果：\n![](/images/perceptron.gif)\n\n##对偶形式\n```\n__author__ = 'wendale'\n\nimport numpy as np\n\nimport draw\n\n\ndef __cal_gram(trains):\n    gram = np.empty((len(trains), len(trains)), np.int)\n    for i in range(len(trains)):\n        for j in range(len(trains)):\n            gram[i][j] = np.dot(trains[i][0], trains[j][0])\n    return gram\n\ndef __check(trains, gram, alpha, b):\n    y = np.array(trains[:,1])\n    for i in range(len(trains)):\n        if (np.dot(alpha * y, gram[i]) + b) * y[i] <= 0:\n            return False, i\n    return True, -1\n\ndef find(trains):\n    gram = __cal_gram(trains)\n    alpha = np.zeros(len(trains))\n    b = 0\n    x = np.array(trains[:,0].tolist()).reshape(3,2)\n    y = np.array(trains[:,1])\n    history = []\n    while True:\n        (flag, i) = __check(trains, gram, alpha, b)\n        if flag:\n            break\n        #update\n        alpha[i] += 1\n        b += trains[i][1]\n        history.append([np.dot(alpha * y, x).tolist(), b])\n    return alpha, b, history\n\nif __name__ == '__main__':\n    trains = np.array([[[3, 3], 1], [[4, 3], 1], [[1, 1], -1]])\n    (a, b, history) = find(trains)\n    draw.show(trains, history, True, 'result/duality_perceptron.gif')\n```\n得到如下结果：\n![](/images/duality_perceptron.gif)\n\n##公共绘图部分代码\n```\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom matplotlib import animation\nfrom functools import partial\n\n# first set up the figure, the axis, and the plot element we want to animate\n__FIG = plt.figure()\n__AX = plt.axes(xlim=(0, 2), ylim=(-2, 2))\n__LINE, = __AX.plot([], [], 'g', lw = 2)\n__LABEL = __AX.text([], [], '')\n\n# initialization function: plot the background of each frame\ndef __init(trains):\n    __LINE.set_data([], [])\n    x, y, x_, y_ = [], [], [], []\n    for p in trains:\n        if p[1] > 0:\n            x.append(p[0][0])\n            y.append(p[0][1])\n        else:\n            x_.append(p[0][0])\n            y_.append(p[0][1])\n\n    plt.plot(x, y, 'bo', x_, y_, 'rx')\n    plt.axis([-6, 6, -6, 6])\n    plt.grid(True)\n    plt.xlabel('x')\n    plt.ylabel('y')\n    plt.title('Prceptron Algorithm(wendale.cn)')\n    return __LINE, __LABEL\n\n# animation function.  this is called sequentially\ndef __animate(history, i):\n    global __AX, __LINE, __LABEL\n\n    w = history[i][0]\n    b = history[i][1]\n    if w[1] == 0:\n        return __LINE, __LABEL\n    x1 = -7\n    y1 = -(b + w[0]*x1)/w[1]\n    x2 = 7\n    y2 = -(b + w[0]*x2)/w[1]\n    __LINE.set_data([x1, x2], [y1, y2])\n    x1 = 0\n    y1 = -(b + w[0] * x1) / w[1]\n    __LABEL.set_text(history[i])\n    __LABEL.set_position([x1, y1])\n    return __LINE, __LABEL\n\ndef show(trains, history, save=False, name=''):\n    # call the animator.  blit=true means only re-draw the parts that have changed.\n    anim = animation.FuncAnimation(__FIG, partial(__animate, history), init_func=partial(__init, trains),\n                                   frames=len(history), interval=1000, repeat=True, blit=True)\n    plt.show()\n    if save:\n        anim.save(name, fps=2, writer='imagemagick')\n\nif __name__ == '__main__':\n    trains = np.array([[(3, 3), 1], [(4, 3), 1], [(1, 1), -1]])\n    history = [[[1.0, 0.0, -0.0], 1], [[1.0, 0.0, -1.0], 0], [[1.0, 0.0, -2.0], -1], [[1.0, 0.0, -3.0], -2], [[2.0, 0.0, -3.0], -1], [[2.0, 0.0, -4.0], -2], [[2.0, 0.0, -5.0], -3]]\n    show(trains, history)\n\n```","source":"_posts/感知机模型-统计学习方法笔记（一）.md","raw":"title: \"感知机模型--统计学习方法笔记（一）\"\ndate: 2015-10-30 20:35:23\ntags: [机器学习]\n---\n通过kaggle的练习，了解了几个分类算法，但是对于算法的原理还不理解。经过推荐，了解了李航的《统计学习方法》，感觉不错。书内容不多，全书主要讲了几种常见的分类算法。内容整体上比较容易理解。最近正好在学习python，python的numpy包在矩阵计算方面也很不错，matplotlib提供类丰富的绘图功能。可以通过matplotlib绘制gif图，这样可以把算法很生动地表现出来。争取以后每章做一篇读书笔记，笔记主要是代码、gif图像以及个人的心得。\n本节对应原书第二章。\n\n##原始形式\n```\nimport copy\n\nimport draw\n\nHISTORY = []\nTRAINS = [[(3, 3), 1], [(4, 3), 1], [(1, 1), -1]]\n\ndef update(w, b, item):\n    for i in range(len(item[0])):\n        w[i] += item[1] * item[0][i]\n    b += item[1]\n    return w, b\n    \ndef cal(item):\n    res = 0\n    for i in range(len(item[0])):\n        res += item[0][i] * w[i]\n    res += b\n    res *= item[1]\n    return res\n    \ndef iterComp(w, b, trains):\n    global HISTORY     \n    flag = False\n    for item in trains:\n        if cal(item) <= 0:\n            flag = True\n            (w, b) = update(w, b, item)\n            HISTORY.append([copy.copy(w), b])\n    if not flag:\n        print \"RESULT:w:\" + str(w) + \"b:\" + str(b)\n    return flag, w, b\n    \nif __name__ == \"__main__\":\n    w = [0, 0]\n    b = 0   \n    while True:\n        (flag, w, b) = iterComp(w, b, TRAINS)\n        if not flag:\n            break\n    draw.show(TRAINS, HISTORY, True, 'result/perceptron.gif')\n```\n得到如下结果：\n![](/images/perceptron.gif)\n\n##对偶形式\n```\n__author__ = 'wendale'\n\nimport numpy as np\n\nimport draw\n\n\ndef __cal_gram(trains):\n    gram = np.empty((len(trains), len(trains)), np.int)\n    for i in range(len(trains)):\n        for j in range(len(trains)):\n            gram[i][j] = np.dot(trains[i][0], trains[j][0])\n    return gram\n\ndef __check(trains, gram, alpha, b):\n    y = np.array(trains[:,1])\n    for i in range(len(trains)):\n        if (np.dot(alpha * y, gram[i]) + b) * y[i] <= 0:\n            return False, i\n    return True, -1\n\ndef find(trains):\n    gram = __cal_gram(trains)\n    alpha = np.zeros(len(trains))\n    b = 0\n    x = np.array(trains[:,0].tolist()).reshape(3,2)\n    y = np.array(trains[:,1])\n    history = []\n    while True:\n        (flag, i) = __check(trains, gram, alpha, b)\n        if flag:\n            break\n        #update\n        alpha[i] += 1\n        b += trains[i][1]\n        history.append([np.dot(alpha * y, x).tolist(), b])\n    return alpha, b, history\n\nif __name__ == '__main__':\n    trains = np.array([[[3, 3], 1], [[4, 3], 1], [[1, 1], -1]])\n    (a, b, history) = find(trains)\n    draw.show(trains, history, True, 'result/duality_perceptron.gif')\n```\n得到如下结果：\n![](/images/duality_perceptron.gif)\n\n##公共绘图部分代码\n```\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom matplotlib import animation\nfrom functools import partial\n\n# first set up the figure, the axis, and the plot element we want to animate\n__FIG = plt.figure()\n__AX = plt.axes(xlim=(0, 2), ylim=(-2, 2))\n__LINE, = __AX.plot([], [], 'g', lw = 2)\n__LABEL = __AX.text([], [], '')\n\n# initialization function: plot the background of each frame\ndef __init(trains):\n    __LINE.set_data([], [])\n    x, y, x_, y_ = [], [], [], []\n    for p in trains:\n        if p[1] > 0:\n            x.append(p[0][0])\n            y.append(p[0][1])\n        else:\n            x_.append(p[0][0])\n            y_.append(p[0][1])\n\n    plt.plot(x, y, 'bo', x_, y_, 'rx')\n    plt.axis([-6, 6, -6, 6])\n    plt.grid(True)\n    plt.xlabel('x')\n    plt.ylabel('y')\n    plt.title('Prceptron Algorithm(wendale.cn)')\n    return __LINE, __LABEL\n\n# animation function.  this is called sequentially\ndef __animate(history, i):\n    global __AX, __LINE, __LABEL\n\n    w = history[i][0]\n    b = history[i][1]\n    if w[1] == 0:\n        return __LINE, __LABEL\n    x1 = -7\n    y1 = -(b + w[0]*x1)/w[1]\n    x2 = 7\n    y2 = -(b + w[0]*x2)/w[1]\n    __LINE.set_data([x1, x2], [y1, y2])\n    x1 = 0\n    y1 = -(b + w[0] * x1) / w[1]\n    __LABEL.set_text(history[i])\n    __LABEL.set_position([x1, y1])\n    return __LINE, __LABEL\n\ndef show(trains, history, save=False, name=''):\n    # call the animator.  blit=true means only re-draw the parts that have changed.\n    anim = animation.FuncAnimation(__FIG, partial(__animate, history), init_func=partial(__init, trains),\n                                   frames=len(history), interval=1000, repeat=True, blit=True)\n    plt.show()\n    if save:\n        anim.save(name, fps=2, writer='imagemagick')\n\nif __name__ == '__main__':\n    trains = np.array([[(3, 3), 1], [(4, 3), 1], [(1, 1), -1]])\n    history = [[[1.0, 0.0, -0.0], 1], [[1.0, 0.0, -1.0], 0], [[1.0, 0.0, -2.0], -1], [[1.0, 0.0, -3.0], -2], [[2.0, 0.0, -3.0], -1], [[2.0, 0.0, -4.0], -2], [[2.0, 0.0, -5.0], -3]]\n    show(trains, history)\n\n```","slug":"感知机模型-统计学习方法笔记（一）","published":1,"updated":"2015-10-30T12:58:27.386Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq9o9r62000btor2kp7i1wom"},{"title":"字符串相关的若干算法","date":"2015-12-05T13:31:17.000Z","_content":"\n## 一. kmp算法\nkmp算法的核心思想是next数组，了解next数组前先了解最长对称串。对于一个字符串s，我们定义：  \n1. s的前缀，以s的首字符开头且不包含尾字符的子串集合。  \n2. s的后缀，以s的尾字符结尾且不包含首字符的的子串集合。  \n最长对乘串：s的前缀集合与后缀集合交集中最长串。  \n例如：  \ns='ababa'  \ns的前缀集合：{a, ab, aba, abab}  \ns的后缀集合: {baba, aba, ba, a}  \n可知s的最长对乘串为aba.  \n定义：  \nnext[i]: s中以索引i为结尾的子串最长对乘串的长度。  \n下面求next[i]:  \n```\ndef cal_next(pattern):\n    next = [0]\n    for i in range(1, len(pattern)):\n        matched = next[i-1]\n        while True:\n            if pattern[matched] == pattern[i]:\n                next.append(matched + 1)\n                break\n            if matched == 0:\n                next.append(0)\n                break\n            matched = next[matched]\n    return next\n```\n匹配过程如下：\n```\ndef kmp(src, pattern):\n    i = 0\n    j = 0\n    match_index = []\n    next = cal_next(pattern)\n    while i < len(src):\n        if src[i] == pattern[j]:\n            i += 1\n            j += 1\n        else:\n            if j == 0:\n                i += 1\n            else:\n                j = next[j-1]\n        if j == len(pattern):\n            match_index.append(i - len(pattern))\n            j = next[j-1]\n    return match_index\n```\n\n## 二、求全排列\n已知字符s1s2s3...sn，求它们的全排列。\n```\ndef next_permutation(permutation):\n    for i in range(len(permutation) - 1, 0, -1):\n        if permutation[i] > permutation[i-1]:\n            min_index = i\n            for j in range(i, len(permutation)):\n                if permutation[i-1] < permutation[j] < permutation[min_index]:\n                    min_index = j\n            permutation[i-1], permutation[min_index] = permutation[min_index], permutation[i-1]\n            m = i\n            n = len(permutation) - 1\n            while m < n:\n                permutation[m], permutation[n] = permutation[n], permutation[m]\n                m += 1\n                n -= 1\n            return permutation\n    return []\n```\n\n## 三、最长回文算法","source":"_posts/字符串相关的若干算法.md","raw":"title: \"字符串相关的若干算法\"\ndate: 2015-12-05 21:31:17\ntags: 算法\n---\n\n## 一. kmp算法\nkmp算法的核心思想是next数组，了解next数组前先了解最长对称串。对于一个字符串s，我们定义：  \n1. s的前缀，以s的首字符开头且不包含尾字符的子串集合。  \n2. s的后缀，以s的尾字符结尾且不包含首字符的的子串集合。  \n最长对乘串：s的前缀集合与后缀集合交集中最长串。  \n例如：  \ns='ababa'  \ns的前缀集合：{a, ab, aba, abab}  \ns的后缀集合: {baba, aba, ba, a}  \n可知s的最长对乘串为aba.  \n定义：  \nnext[i]: s中以索引i为结尾的子串最长对乘串的长度。  \n下面求next[i]:  \n```\ndef cal_next(pattern):\n    next = [0]\n    for i in range(1, len(pattern)):\n        matched = next[i-1]\n        while True:\n            if pattern[matched] == pattern[i]:\n                next.append(matched + 1)\n                break\n            if matched == 0:\n                next.append(0)\n                break\n            matched = next[matched]\n    return next\n```\n匹配过程如下：\n```\ndef kmp(src, pattern):\n    i = 0\n    j = 0\n    match_index = []\n    next = cal_next(pattern)\n    while i < len(src):\n        if src[i] == pattern[j]:\n            i += 1\n            j += 1\n        else:\n            if j == 0:\n                i += 1\n            else:\n                j = next[j-1]\n        if j == len(pattern):\n            match_index.append(i - len(pattern))\n            j = next[j-1]\n    return match_index\n```\n\n## 二、求全排列\n已知字符s1s2s3...sn，求它们的全排列。\n```\ndef next_permutation(permutation):\n    for i in range(len(permutation) - 1, 0, -1):\n        if permutation[i] > permutation[i-1]:\n            min_index = i\n            for j in range(i, len(permutation)):\n                if permutation[i-1] < permutation[j] < permutation[min_index]:\n                    min_index = j\n            permutation[i-1], permutation[min_index] = permutation[min_index], permutation[i-1]\n            m = i\n            n = len(permutation) - 1\n            while m < n:\n                permutation[m], permutation[n] = permutation[n], permutation[m]\n                m += 1\n                n -= 1\n            return permutation\n    return []\n```\n\n## 三、最长回文算法","slug":"字符串相关的若干算法","published":1,"updated":"2015-12-05T13:47:01.121Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq9o9r65000etor2qq6md0tt"},{"title":"O(1)复杂度实现单链表的插入删除操作","date":"2015-05-10T03:45:27.000Z","_content":"\n## 插入 ##\n\t插入是指在某个节点之前插入一个新的节点，由于要找到前置节点，所以时间复杂度是O(n)。怎样实现O(1)的插入呢？我们得换一种思维方式，肯定是不能找前置节点，但我们可以交换节点和待插入节点的值，这样前置节点的next指针值没变，但是指向的内存地址的值已经是新节点的值了。\n\n## 删除 ##\n\t思路和插入的思路基本一样，就是交换节点和他的next节点，但是如何next节点为NULL,那就没办法了，得老老实实找到上一个节点。\n\t\n\n\n----------\n直接上代码：\n\n```\n    class Node {\n\tpublic:\n\t    int value;\n\t    Node*   next;\n\n\t    ~Node() {\n\t\tif (next != NULL) {\n\t\t    delete next;\n\t\t}\n\t    }\n\n\t    /**\n\t     * 与q交换内存值\n\t     */\n\t    void exchange(Node* q) {\n\t\tNode* tmp = new Node();\n\t\tmemcpy(tmp, this, sizeof(Node));\n\t\tmemcpy(this, q, sizeof(Node));\n\t\tmemcpy(q, tmp, sizeof(Node));\n\t    }\n\n\t};\n\n\tclass NodeList {\n\tprivate:\n\t    Node* head;\n\n\t    /**\n\t     * 找到p的前置节点\n\t     */\n\t    Node*find_pre(Node *p) {\n\t\tNode* l = head;\n\n\t\twhile (l->next != p) {\n\t\t    l = l->next;\n\t\t}\n\n\t\treturn l;\n\t    }\n\n\tpublic:\n\t    NodeList() {\n\t\thead = new Node();\n\t\thead->value = 0;\n\t\thead->next = NULL;\n\t    }\n\n\t    ~NodeList() {\n\t\tNode* p = head;\n\t\tNode* q = NULL;\n\t\twhile (p != NULL) {\n\t\t    q = p;\n\t\t    p = p->next;\n\t\t    delete q;\n\t\t}\n\t    }\n\n\t    /**\n\t     * 在链表末尾追加\n\t     */\n\t    void add(Node* p) {\n\t\tNode* q = find_pre(NULL);\n\t\tq->next = p;\n\t\tp->next = NULL;\n\t    }\n\n\t    /**\n\t     * 在链表节点p之前插入q,这种实现的复杂度O(n)\n\t     */\n\t    void insert(Node* p, Node* q) {\n\t\tNode* l = find_pre(p);\n\n\t\tl->next = q;\n\t\tq->next = p;\n\t    }\n\n\t    /**\n\t     * 在链表节点p之前插入q,这种实现的复杂度O(1)\n\t     */\n\t    void quick_insert(Node* p, Node* q) {\n\t\tp->exchange(q);\n\t\tp->next = q;\n\t    }\n\n\t    /**\n\t     * 移除p，时间复杂度O(n)\n\t     */\n\t    void remove(Node* p) {\n\t\tNode* q = find_pre(p);\n\t\tq->next = NULL;\n\t\tdelete p;\n\t    }\n\n\t    /**\n\t     * 快速移除p，时间复杂度O(1)\n\t     */\n\t    void quick_remove(Node* p) {\n\t\t//最后一个节点，没办法，只能用慢删除\n\t\tif (p->next == NULL) {\n\t\t    remove(p);\n\t\t}\n\t\tNode* q = p->next;\n\t\tp->exchange(p->next);\n\t\tdelete q;\n\t    }\n\n\t};\n```\n\n\n","source":"_posts/单链表O(1)插入删除.md","raw":"title: \"O(1)复杂度实现单链表的插入删除操作\"\ndate: 2015-05-10 11:45:27\ntags: 笔试题\n---\n\n## 插入 ##\n\t插入是指在某个节点之前插入一个新的节点，由于要找到前置节点，所以时间复杂度是O(n)。怎样实现O(1)的插入呢？我们得换一种思维方式，肯定是不能找前置节点，但我们可以交换节点和待插入节点的值，这样前置节点的next指针值没变，但是指向的内存地址的值已经是新节点的值了。\n\n## 删除 ##\n\t思路和插入的思路基本一样，就是交换节点和他的next节点，但是如何next节点为NULL,那就没办法了，得老老实实找到上一个节点。\n\t\n\n\n----------\n直接上代码：\n\n```\n    class Node {\n\tpublic:\n\t    int value;\n\t    Node*   next;\n\n\t    ~Node() {\n\t\tif (next != NULL) {\n\t\t    delete next;\n\t\t}\n\t    }\n\n\t    /**\n\t     * 与q交换内存值\n\t     */\n\t    void exchange(Node* q) {\n\t\tNode* tmp = new Node();\n\t\tmemcpy(tmp, this, sizeof(Node));\n\t\tmemcpy(this, q, sizeof(Node));\n\t\tmemcpy(q, tmp, sizeof(Node));\n\t    }\n\n\t};\n\n\tclass NodeList {\n\tprivate:\n\t    Node* head;\n\n\t    /**\n\t     * 找到p的前置节点\n\t     */\n\t    Node*find_pre(Node *p) {\n\t\tNode* l = head;\n\n\t\twhile (l->next != p) {\n\t\t    l = l->next;\n\t\t}\n\n\t\treturn l;\n\t    }\n\n\tpublic:\n\t    NodeList() {\n\t\thead = new Node();\n\t\thead->value = 0;\n\t\thead->next = NULL;\n\t    }\n\n\t    ~NodeList() {\n\t\tNode* p = head;\n\t\tNode* q = NULL;\n\t\twhile (p != NULL) {\n\t\t    q = p;\n\t\t    p = p->next;\n\t\t    delete q;\n\t\t}\n\t    }\n\n\t    /**\n\t     * 在链表末尾追加\n\t     */\n\t    void add(Node* p) {\n\t\tNode* q = find_pre(NULL);\n\t\tq->next = p;\n\t\tp->next = NULL;\n\t    }\n\n\t    /**\n\t     * 在链表节点p之前插入q,这种实现的复杂度O(n)\n\t     */\n\t    void insert(Node* p, Node* q) {\n\t\tNode* l = find_pre(p);\n\n\t\tl->next = q;\n\t\tq->next = p;\n\t    }\n\n\t    /**\n\t     * 在链表节点p之前插入q,这种实现的复杂度O(1)\n\t     */\n\t    void quick_insert(Node* p, Node* q) {\n\t\tp->exchange(q);\n\t\tp->next = q;\n\t    }\n\n\t    /**\n\t     * 移除p，时间复杂度O(n)\n\t     */\n\t    void remove(Node* p) {\n\t\tNode* q = find_pre(p);\n\t\tq->next = NULL;\n\t\tdelete p;\n\t    }\n\n\t    /**\n\t     * 快速移除p，时间复杂度O(1)\n\t     */\n\t    void quick_remove(Node* p) {\n\t\t//最后一个节点，没办法，只能用慢删除\n\t\tif (p->next == NULL) {\n\t\t    remove(p);\n\t\t}\n\t\tNode* q = p->next;\n\t\tp->exchange(p->next);\n\t\tdelete q;\n\t    }\n\n\t};\n```\n\n\n","slug":"单链表O(1)插入删除","published":1,"updated":"2015-09-24T10:26:06.215Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq9o9r68000htor2u8eg3cg3"},{"title":"利用netcat快速搭建http服务","date":"2015-11-11T08:18:13.000Z","_content":"\n##netcat\nnetcat是linux系统自带的一个网络工具，通过，netcat的应用非常多，比如做代理，端口扫描，聊天服务器等，被誉为linux网络工具中的瑞士军刀，关于各种应用场景的介绍，可以参考下面参考1的链接。本文要分享的是netcat在工作中的一次应用：提供http服务。\n\n##需求场景\n场景是这样的，我在和其他部门联调测试，本质上就是对方把数据推过来了，我手动触发处理，然后再把结果推过去。每次联调都要沟通，相当麻烦，觉得应该想办法提高效率。其实联调中我的作用就下面三点：\n1. 清空历史数据\n2. 查看数据是否接受到\n3. 调用数据处理程序，并把处理结果同步过去。\n\n其实完全可以让对方登陆到我的测试机器，但是总觉得这样不妥，万一我那高雅的代码被人看到了呢～～。所以我希望别人能够在我的机器执行以上三个操作，在不登陆我的机器前提下。想起之前用nc做过代理服务，就试了下提供个http服务：\n\n##处理逻辑\n```\n#step 1 读取请求信息\nread request\n\nwhile /bin/true; do\n  read header\n  [ \"$header\" == $'\\r' ] && break;\ndone\n\n#step 2 提取url\nurl=\"${request#GET }\"\nurl=\"${url% HTTP/*}\"\n\n#step 3 解析命令，返回结果\necho -e \"HTTP/1.1 200 OK\\r\"\necho -e \"Content-Type: text/plain; charset=utf-8\\r\"\necho -e \"\\r\"\ncase $url in\n#接口1：清空数据\n    '/clear')\n        echo '开始清除历史数据...'\n        rm ./out/*.txt\n        echo '数据已清除!OK'\n        ;;\n#接口3：调用数据处理程序，并把处理结果同步过去\n    '/exec')\n        echo '执行排名统计并同步数据..'\n        ./batch.sh\n        if [[ $? -eq 0 ]];then\n            echo '执行成功！OK'\n        else\n            echo '执行失败！error'\n        fi\n        ;;\n#接口2：查看数据\n    '/watch')\n        i=0\n        while read line\n        do\n            if [[ $line == 4* ]]; then\n                i=$(($i+1))\n                echo $line\n            fi\n        done < ./out/json_result.txt\n        echo \"共$i行\"\n        ;;\n         *)\n        echo '非法操作'\n        ;;\nesac\n```\n##服务驱动\nnc监听端口，将接受到的数据丢给处理逻辑，处理逻辑处理完再交给nc，此处用双向管道实现循环管道\n```\nDPIPE=\"/tmp/static_server\"\necho \"删除双向管道${DPIPE}（如果存在的话）...\"\nrm -f $DPIPE\necho \"创建双向管道【${DPIPE}】...\"\nmkfifo $DPIPE\necho \"服务开始...\"\nwhile /bin/true; do\n    cat $DPIPE | ./static_server.sh | nc -l 127.0.0.1 8080 > $DPIPE\ndone\n```\n非常的轻量级，开发这个接口加测试不到一个小时，python3的http.server也能很快实现这样的功能，有机会也试下。\n\n[netcat应用场景介绍](http://www.oschina.net/translate/linux-netcat-command)\n\n","source":"_posts/利用netcat快速搭建http服务.md","raw":"title: \"利用netcat快速搭建http服务\"\ndate: 2015-11-11 16:18:13\ntags: linux\n---\n\n##netcat\nnetcat是linux系统自带的一个网络工具，通过，netcat的应用非常多，比如做代理，端口扫描，聊天服务器等，被誉为linux网络工具中的瑞士军刀，关于各种应用场景的介绍，可以参考下面参考1的链接。本文要分享的是netcat在工作中的一次应用：提供http服务。\n\n##需求场景\n场景是这样的，我在和其他部门联调测试，本质上就是对方把数据推过来了，我手动触发处理，然后再把结果推过去。每次联调都要沟通，相当麻烦，觉得应该想办法提高效率。其实联调中我的作用就下面三点：\n1. 清空历史数据\n2. 查看数据是否接受到\n3. 调用数据处理程序，并把处理结果同步过去。\n\n其实完全可以让对方登陆到我的测试机器，但是总觉得这样不妥，万一我那高雅的代码被人看到了呢～～。所以我希望别人能够在我的机器执行以上三个操作，在不登陆我的机器前提下。想起之前用nc做过代理服务，就试了下提供个http服务：\n\n##处理逻辑\n```\n#step 1 读取请求信息\nread request\n\nwhile /bin/true; do\n  read header\n  [ \"$header\" == $'\\r' ] && break;\ndone\n\n#step 2 提取url\nurl=\"${request#GET }\"\nurl=\"${url% HTTP/*}\"\n\n#step 3 解析命令，返回结果\necho -e \"HTTP/1.1 200 OK\\r\"\necho -e \"Content-Type: text/plain; charset=utf-8\\r\"\necho -e \"\\r\"\ncase $url in\n#接口1：清空数据\n    '/clear')\n        echo '开始清除历史数据...'\n        rm ./out/*.txt\n        echo '数据已清除!OK'\n        ;;\n#接口3：调用数据处理程序，并把处理结果同步过去\n    '/exec')\n        echo '执行排名统计并同步数据..'\n        ./batch.sh\n        if [[ $? -eq 0 ]];then\n            echo '执行成功！OK'\n        else\n            echo '执行失败！error'\n        fi\n        ;;\n#接口2：查看数据\n    '/watch')\n        i=0\n        while read line\n        do\n            if [[ $line == 4* ]]; then\n                i=$(($i+1))\n                echo $line\n            fi\n        done < ./out/json_result.txt\n        echo \"共$i行\"\n        ;;\n         *)\n        echo '非法操作'\n        ;;\nesac\n```\n##服务驱动\nnc监听端口，将接受到的数据丢给处理逻辑，处理逻辑处理完再交给nc，此处用双向管道实现循环管道\n```\nDPIPE=\"/tmp/static_server\"\necho \"删除双向管道${DPIPE}（如果存在的话）...\"\nrm -f $DPIPE\necho \"创建双向管道【${DPIPE}】...\"\nmkfifo $DPIPE\necho \"服务开始...\"\nwhile /bin/true; do\n    cat $DPIPE | ./static_server.sh | nc -l 127.0.0.1 8080 > $DPIPE\ndone\n```\n非常的轻量级，开发这个接口加测试不到一个小时，python3的http.server也能很快实现这样的功能，有机会也试下。\n\n[netcat应用场景介绍](http://www.oschina.net/translate/linux-netcat-command)\n\n","slug":"利用netcat快速搭建http服务","published":1,"updated":"2015-11-13T12:51:33.591Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq9o9r6a000jtor24e5rympa"},{"title":"几道笔试题","date":"2015-10-30T13:00:49.000Z","_content":"\n最近开始用python了，正好公司过段时间研发人员考试，整几个校招笔试题练手吧。\n\n#第一题\n> 如何在排序数组中，找出给定数字出现次数？ 比如：{0,1,2,3,3,3,3,3,3,3,3,4,5,6,7,13,19}\n\n解法非常多，但是要考虑最坏情况下也要有较好的性能，抓住排好序的属性。下面使用的是稍加修改的二分查找，两次二分分别找到上下界，直接相减即可。\n```\ndef binFindUp(arr, key):\n    low = 0\n    high = len(arr) -1\n    while(low < high): \n        print \"%d,%d\" % (low, high)\n        mid = (low + high) / 2       \n        if (arr[mid] <= key):\n            low = mid\n        else:\n            high = mid - 1             \n    return low               \n    \ndef binFindDown(arr, key):\n    low = 0\n    high = len(arr) -1\n    while(low < high): \n        print \"%d,%d\" % (low, high)\n        mid = (low + high) / 2       \n        if (arr[mid] >= key):\n            high = mid\n        else:\n            low = mid + 1             \n    return high    \n```\n#第二题\n>如何计算两个有序整形数组的交集,比如：\na=0,1,2,3,4\nb=1,3,5,7,9\n\n由于求交集，交集一定是集合之间的运算，所以说a,b是集合，即它们本身不含重复元素，参考归并排序的方法即可。\n```\ndef interset(a, b)\n    i = 0\n    j = 0\n    c = []\n    while i < len(a) and b < len(b):\n        if a[i] == b[j]:\n            c.add(a[i])\n            i++\n            j++\n        else if a[i] > b[j]:\n            i++\n        else:\n            j++\n    return c\n```\n\n下面两题是评估字符串相似度的，在工程上都有广泛的应该用。解决思路基本一致，都用的动态规划的思想：\n#第三题\n>求最长公共子串\n```\ndef lcs(str1, str2):\n    dp = [[0 for col in range(len(str2) + 1)] for row in range(len(str1) + 1)]\n    for i in range(1, len(str1) + 1):\n        for j in range(1, len(str2) + 1):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1] + (1 if str1[i-1] == str2[j-1] else 0))     \n    return dp[len(str1)][len(str2)]\n```\n\n#第四题\n>字符串编辑距离\n```\ndef leven(str1, str2):\n    dp = [[0 for col in range(len(str2) + 1)] for row in range(len(str1) + 1)]\n    for i in range(0, len(str1) + 1):\n        for j in range(0, len(str2) + 1):\n            if i == 0 or j == 0:\n                dp[i][j] = i + j\n            else:           \n                dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + (0 if str1[i-1] == str2[j-1] else 1))     \n    return dp[len(str1)][len(str2)]    \n```\n\n#第五题\n>求无序数组的第n小值。如果排序再求，那么是nlgn的时间复杂度，下面是一个n的线性复杂度，可用来求最大值，最小值，中位数等。\n\n```\ndef npos(lst, n):\n    index = random.randint(0, len(lst) - 1)\n    big = [l for l in lst if l > lst[index]]\n    little = [l for l in lst if l < lst[index]]\n    equal = [l for l in lst if l == lst[index]]\n    if len(little) > n - 1:\n        return npos(little, n)\n    if len(little) <= n - 1:\n        if len(little) + len(equal) >= n:\n            return lst[index]\n        return npos(big, n - len(little) - len(equal))\n```","source":"_posts/几道笔试题.md","raw":"title: \"几道笔试题\"\ndate: 2015-10-30 21:00:49\ntags: 笔试题\n---\n\n最近开始用python了，正好公司过段时间研发人员考试，整几个校招笔试题练手吧。\n\n#第一题\n> 如何在排序数组中，找出给定数字出现次数？ 比如：{0,1,2,3,3,3,3,3,3,3,3,4,5,6,7,13,19}\n\n解法非常多，但是要考虑最坏情况下也要有较好的性能，抓住排好序的属性。下面使用的是稍加修改的二分查找，两次二分分别找到上下界，直接相减即可。\n```\ndef binFindUp(arr, key):\n    low = 0\n    high = len(arr) -1\n    while(low < high): \n        print \"%d,%d\" % (low, high)\n        mid = (low + high) / 2       \n        if (arr[mid] <= key):\n            low = mid\n        else:\n            high = mid - 1             \n    return low               \n    \ndef binFindDown(arr, key):\n    low = 0\n    high = len(arr) -1\n    while(low < high): \n        print \"%d,%d\" % (low, high)\n        mid = (low + high) / 2       \n        if (arr[mid] >= key):\n            high = mid\n        else:\n            low = mid + 1             \n    return high    \n```\n#第二题\n>如何计算两个有序整形数组的交集,比如：\na=0,1,2,3,4\nb=1,3,5,7,9\n\n由于求交集，交集一定是集合之间的运算，所以说a,b是集合，即它们本身不含重复元素，参考归并排序的方法即可。\n```\ndef interset(a, b)\n    i = 0\n    j = 0\n    c = []\n    while i < len(a) and b < len(b):\n        if a[i] == b[j]:\n            c.add(a[i])\n            i++\n            j++\n        else if a[i] > b[j]:\n            i++\n        else:\n            j++\n    return c\n```\n\n下面两题是评估字符串相似度的，在工程上都有广泛的应该用。解决思路基本一致，都用的动态规划的思想：\n#第三题\n>求最长公共子串\n```\ndef lcs(str1, str2):\n    dp = [[0 for col in range(len(str2) + 1)] for row in range(len(str1) + 1)]\n    for i in range(1, len(str1) + 1):\n        for j in range(1, len(str2) + 1):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1], dp[i-1][j-1] + (1 if str1[i-1] == str2[j-1] else 0))     \n    return dp[len(str1)][len(str2)]\n```\n\n#第四题\n>字符串编辑距离\n```\ndef leven(str1, str2):\n    dp = [[0 for col in range(len(str2) + 1)] for row in range(len(str1) + 1)]\n    for i in range(0, len(str1) + 1):\n        for j in range(0, len(str2) + 1):\n            if i == 0 or j == 0:\n                dp[i][j] = i + j\n            else:           \n                dp[i][j] = min(dp[i-1][j] + 1, dp[i][j-1] + 1, dp[i-1][j-1] + (0 if str1[i-1] == str2[j-1] else 1))     \n    return dp[len(str1)][len(str2)]    \n```\n\n#第五题\n>求无序数组的第n小值。如果排序再求，那么是nlgn的时间复杂度，下面是一个n的线性复杂度，可用来求最大值，最小值，中位数等。\n\n```\ndef npos(lst, n):\n    index = random.randint(0, len(lst) - 1)\n    big = [l for l in lst if l > lst[index]]\n    little = [l for l in lst if l < lst[index]]\n    equal = [l for l in lst if l == lst[index]]\n    if len(little) > n - 1:\n        return npos(little, n)\n    if len(little) <= n - 1:\n        if len(little) + len(equal) >= n:\n            return lst[index]\n        return npos(big, n - len(little) - len(equal))\n```","slug":"几道笔试题","published":1,"updated":"2015-10-30T13:02:34.996Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq9o9r6c000mtor2kcrwjlpb"},{"title":"优先级矩阵求算数表达式","date":"2015-12-01T04:21:35.000Z","_content":"\n算数表达式求值是现代编译器要解决的最基本的问题。所谓表达式，就是包含常数、变量以及数学运算符、逻辑运算符、括号等的字符串。本次为了练习，只考虑包括加减乘除、正负号、括号的表达式。\n\n---\n\n##1. 优先级\n我们让右括号的优先级最低，左括号最高，其次正负号，其次乘除，最后加减，同一优先级左结合性时左面的高，右结核性右面高，加减乘除均是左结合性，正负号右结合性，左括号右结合性，右括号左结合性。综上可得优先级矩阵：\n\n```\n\n# row represent left operator\n\n# col represent right operator\n\n# PRIORITY_MATRIX[i][j] is True when i has high priority, otherwise, i has low priority\n\nPRIORITY_MATRIX = (\n\n# +,-,*,/,+(sign),-(sign),(,)\n\n(True,True,False,False,False,False,False,True),#+\n\n(True,True,False,False,False,False,False,True),#-\n\n(True,True,True,True,False,False,False,True),#*\n\n(True,True,True,True,False,False,False,True),#/\n\n(True,True,True,True,False,False,False,True),#+(sign)\n\n(True,True,True,True,False,False,False,True),#-(sign)\n\n(False,False,False,False,False,False,False,True),#(\n\n(True,True,True,True,True,True,True,True)#)\n\n)\n\n#符号编码\nPLUS_OPERATOR = 0\nMINUS_OPERATOR = 1\nMULTIPLY_OPERATOR = 2\nDIVIDE_OPERATOR = 3\nPOSITIVE_SIGN_OPERATOR = 4\nNEGATIVE_SIGN_OPERATOR = 5\nLEFT_BRACKET_OPERATOR = 6\nRIGHT_BRACKET_OPERATOR = 7\n```\nPRIORITY_MATRIX[op1][op2]的含义是:操作符op1在左，op2在右，op1的优先级是否高于op2.\n\n##2. 表达式符号解析\n首先要解析表达式，此时需要注意的是正负号的识别，因为加减和正负号分别是同一个字符。那么当面对一个'+'或者'-'字符的情况下如何判断它到底是哪一种符号呢？\n**如果上一个符号是数字或者右括号，那么就是加减号，否则为正负号.**\n有了上面的规则符号解析就很容易了：\n```\ndef push_num(tokens, current_num):\n    if current_num:\n        try:\n            tokens.append(Token(False, float(''.join(current_num))))\n            del current_num[:]\n        except Exception:\n            raise Exception('parse num failed')\n\n\ndef judge_operator(tokens, ch):\n    last_token = tokens[-1]\n    if ch == '+':\n        if last_token.is_operator and last_token.value != RIGHT_BRACKET_OPERATOR:\n            op = POSITIVE_SIGN_OPERATOR\n        else:\n            op = PLUS_OPERATOR\n    elif ch == '-':\n        if last_token.is_operator and last_token.value != RIGHT_BRACKET_OPERATOR:\n            op = NEGATIVE_SIGN_OPERATOR\n        else:\n            op = MINUS_OPERATOR\n    elif ch == '*':\n        op = MULTIPLY_OPERATOR\n    elif ch == '/':\n        op = DIVIDE_OPERATOR\n    elif ch == '(':\n        op = LEFT_BRACKET_OPERATOR\n    elif ch == ')':\n        op = RIGHT_BRACKET_OPERATOR\n    else:\n        raise Exception('unknown operator ' + ch)\n    return op\n\n\ndef parse_tokens(expression):\n    tokens = [Token(True, LEFT_BRACKET_OPERATOR)]\n    current_num = []\n    for ch in expression + ')':\n        if '0' <= ch <= '9' or ch == '.':\n            current_num.append(ch)\n        else:\n            push_num(tokens, current_num)\n            if ch == ' ':\n                continue\n            op = judge_operator(tokens, ch)\n            tokens.append(Token(True, op))\n    return tokens\n```\n在解析符号的，为了后续计算不失一般性，在表达式首尾分别加上左右括号。\n\n##3. 计算值\n这里使用两个栈来分别存放操作数(operand_stack)和操作符(operator_stack),计算过程如下。\n从前往后遍历符号表：\n&nbsp;&nbsp;&nbsp;&nbsp;1)如果是数字，入操作数栈\n&nbsp;&nbsp;&nbsp;&nbsp;2)如果是操作符，设为op，重复以下过程：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a）取操作符栈顶操作符top.\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b）如果top优先级小于op，则将op压入操作符栈，结束循环。\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c）如果top优先级大于op，弹出top,从操作数栈弹出相应数目的操作数，计算结果并压入操作数栈。如果top是左括号，结束循环，否则继续循环。\n```\nOP_MAP = {\n    PLUS_OPERATOR: lambda x, y: x + y,\n    MINUS_OPERATOR: lambda x, y: x - y,\n    MULTIPLY_OPERATOR: lambda x, y: x * y,\n    DIVIDE_OPERATOR: lambda x, y: x / y,\n    POSITIVE_SIGN_OPERATOR: lambda x: x,\n    NEGATIVE_SIGN_OPERATOR: lambda x: -x,\n    LEFT_BRACKET_OPERATOR: lambda x: x\n}\n\n\ndef do_binary_operator_calculate(operand_stack, op):\n    if len(operand_stack) < 2:\n        raise Exception('not enough operand for operator %d' % op)\n    right = operand_stack.pop()\n    left = operand_stack.pop()\n    if op == DIVIDE_OPERATOR and right == 0:\n        raise Exception('divisor can not be zero')\n    operand_stack.append(OP_MAP[op](left, right))\n\n\ndef do_unary_operator_calculate(operand_stack, op):\n    if len(operand_stack) < 1:\n        raise Exception('not enough operand for operator %d' % op)\n    operand_stack.append(OP_MAP[op](operand_stack.pop()))\n\n\ndef on_op(operator_stack, operand_stack, op):\n    if not operator_stack:\n        raise Exception('operator should be empty')\n    if PRIORITY_MATRIX[operator_stack[-1]][op]:\n        last_op = operator_stack.pop()\n        if last_op in (PLUS_OPERATOR, MINUS_OPERATOR, MULTIPLY_OPERATOR, DIVIDE_OPERATOR):\n            do_binary_operator_calculate(operand_stack, last_op)\n            on_op(operator_stack, operand_stack, op)\n        else:\n            do_unary_operator_calculate(operand_stack, last_op)\n            if last_op != LEFT_BRACKET_OPERATOR:\n                on_op(operator_stack, operand_stack, op)\n    else:\n        operator_stack.append(op)\n        \n\ndef calculate(expression):\n    tokens = parse_tokens(expression)\n    operator_stack = [tokens[0].value]\n    operand_stack = []\n    for token in tokens[1:]:\n        if token.is_operator:\n            on_op(operator_stack, operand_stack, token.value)\n        else:\n            operand_stack.append(token.value)\n    if len(operand_stack) != 1:\n        raise Exception('too many operand left')\n    if operator_stack:\n        raise Exception('operator left')\n    return operand_stack.pop()\n```\n到这已经完成了算数表达式的计算。需要注意的是异常情况的处理。下面再加上主函数，一个简易计算器就实现了：\n```\nif __name__ == '__main__':\n    while True:\n        text = raw_input('>>>')\n        print(calculate(text))\n```\n\n","source":"_posts/优先级矩阵求表达式的值.md","raw":"title: \"优先级矩阵求算数表达式\"\ndate: 2015-12-01 12:21:35\ntags: 算法\n---\n\n算数表达式求值是现代编译器要解决的最基本的问题。所谓表达式，就是包含常数、变量以及数学运算符、逻辑运算符、括号等的字符串。本次为了练习，只考虑包括加减乘除、正负号、括号的表达式。\n\n---\n\n##1. 优先级\n我们让右括号的优先级最低，左括号最高，其次正负号，其次乘除，最后加减，同一优先级左结合性时左面的高，右结核性右面高，加减乘除均是左结合性，正负号右结合性，左括号右结合性，右括号左结合性。综上可得优先级矩阵：\n\n```\n\n# row represent left operator\n\n# col represent right operator\n\n# PRIORITY_MATRIX[i][j] is True when i has high priority, otherwise, i has low priority\n\nPRIORITY_MATRIX = (\n\n# +,-,*,/,+(sign),-(sign),(,)\n\n(True,True,False,False,False,False,False,True),#+\n\n(True,True,False,False,False,False,False,True),#-\n\n(True,True,True,True,False,False,False,True),#*\n\n(True,True,True,True,False,False,False,True),#/\n\n(True,True,True,True,False,False,False,True),#+(sign)\n\n(True,True,True,True,False,False,False,True),#-(sign)\n\n(False,False,False,False,False,False,False,True),#(\n\n(True,True,True,True,True,True,True,True)#)\n\n)\n\n#符号编码\nPLUS_OPERATOR = 0\nMINUS_OPERATOR = 1\nMULTIPLY_OPERATOR = 2\nDIVIDE_OPERATOR = 3\nPOSITIVE_SIGN_OPERATOR = 4\nNEGATIVE_SIGN_OPERATOR = 5\nLEFT_BRACKET_OPERATOR = 6\nRIGHT_BRACKET_OPERATOR = 7\n```\nPRIORITY_MATRIX[op1][op2]的含义是:操作符op1在左，op2在右，op1的优先级是否高于op2.\n\n##2. 表达式符号解析\n首先要解析表达式，此时需要注意的是正负号的识别，因为加减和正负号分别是同一个字符。那么当面对一个'+'或者'-'字符的情况下如何判断它到底是哪一种符号呢？\n**如果上一个符号是数字或者右括号，那么就是加减号，否则为正负号.**\n有了上面的规则符号解析就很容易了：\n```\ndef push_num(tokens, current_num):\n    if current_num:\n        try:\n            tokens.append(Token(False, float(''.join(current_num))))\n            del current_num[:]\n        except Exception:\n            raise Exception('parse num failed')\n\n\ndef judge_operator(tokens, ch):\n    last_token = tokens[-1]\n    if ch == '+':\n        if last_token.is_operator and last_token.value != RIGHT_BRACKET_OPERATOR:\n            op = POSITIVE_SIGN_OPERATOR\n        else:\n            op = PLUS_OPERATOR\n    elif ch == '-':\n        if last_token.is_operator and last_token.value != RIGHT_BRACKET_OPERATOR:\n            op = NEGATIVE_SIGN_OPERATOR\n        else:\n            op = MINUS_OPERATOR\n    elif ch == '*':\n        op = MULTIPLY_OPERATOR\n    elif ch == '/':\n        op = DIVIDE_OPERATOR\n    elif ch == '(':\n        op = LEFT_BRACKET_OPERATOR\n    elif ch == ')':\n        op = RIGHT_BRACKET_OPERATOR\n    else:\n        raise Exception('unknown operator ' + ch)\n    return op\n\n\ndef parse_tokens(expression):\n    tokens = [Token(True, LEFT_BRACKET_OPERATOR)]\n    current_num = []\n    for ch in expression + ')':\n        if '0' <= ch <= '9' or ch == '.':\n            current_num.append(ch)\n        else:\n            push_num(tokens, current_num)\n            if ch == ' ':\n                continue\n            op = judge_operator(tokens, ch)\n            tokens.append(Token(True, op))\n    return tokens\n```\n在解析符号的，为了后续计算不失一般性，在表达式首尾分别加上左右括号。\n\n##3. 计算值\n这里使用两个栈来分别存放操作数(operand_stack)和操作符(operator_stack),计算过程如下。\n从前往后遍历符号表：\n&nbsp;&nbsp;&nbsp;&nbsp;1)如果是数字，入操作数栈\n&nbsp;&nbsp;&nbsp;&nbsp;2)如果是操作符，设为op，重复以下过程：\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a）取操作符栈顶操作符top.\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b）如果top优先级小于op，则将op压入操作符栈，结束循环。\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c）如果top优先级大于op，弹出top,从操作数栈弹出相应数目的操作数，计算结果并压入操作数栈。如果top是左括号，结束循环，否则继续循环。\n```\nOP_MAP = {\n    PLUS_OPERATOR: lambda x, y: x + y,\n    MINUS_OPERATOR: lambda x, y: x - y,\n    MULTIPLY_OPERATOR: lambda x, y: x * y,\n    DIVIDE_OPERATOR: lambda x, y: x / y,\n    POSITIVE_SIGN_OPERATOR: lambda x: x,\n    NEGATIVE_SIGN_OPERATOR: lambda x: -x,\n    LEFT_BRACKET_OPERATOR: lambda x: x\n}\n\n\ndef do_binary_operator_calculate(operand_stack, op):\n    if len(operand_stack) < 2:\n        raise Exception('not enough operand for operator %d' % op)\n    right = operand_stack.pop()\n    left = operand_stack.pop()\n    if op == DIVIDE_OPERATOR and right == 0:\n        raise Exception('divisor can not be zero')\n    operand_stack.append(OP_MAP[op](left, right))\n\n\ndef do_unary_operator_calculate(operand_stack, op):\n    if len(operand_stack) < 1:\n        raise Exception('not enough operand for operator %d' % op)\n    operand_stack.append(OP_MAP[op](operand_stack.pop()))\n\n\ndef on_op(operator_stack, operand_stack, op):\n    if not operator_stack:\n        raise Exception('operator should be empty')\n    if PRIORITY_MATRIX[operator_stack[-1]][op]:\n        last_op = operator_stack.pop()\n        if last_op in (PLUS_OPERATOR, MINUS_OPERATOR, MULTIPLY_OPERATOR, DIVIDE_OPERATOR):\n            do_binary_operator_calculate(operand_stack, last_op)\n            on_op(operator_stack, operand_stack, op)\n        else:\n            do_unary_operator_calculate(operand_stack, last_op)\n            if last_op != LEFT_BRACKET_OPERATOR:\n                on_op(operator_stack, operand_stack, op)\n    else:\n        operator_stack.append(op)\n        \n\ndef calculate(expression):\n    tokens = parse_tokens(expression)\n    operator_stack = [tokens[0].value]\n    operand_stack = []\n    for token in tokens[1:]:\n        if token.is_operator:\n            on_op(operator_stack, operand_stack, token.value)\n        else:\n            operand_stack.append(token.value)\n    if len(operand_stack) != 1:\n        raise Exception('too many operand left')\n    if operator_stack:\n        raise Exception('operator left')\n    return operand_stack.pop()\n```\n到这已经完成了算数表达式的计算。需要注意的是异常情况的处理。下面再加上主函数，一个简易计算器就实现了：\n```\nif __name__ == '__main__':\n    while True:\n        text = raw_input('>>>')\n        print(calculate(text))\n```\n\n","slug":"优先级矩阵求表达式的值","published":1,"updated":"2015-12-01T13:29:46.809Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq9o9r6e000otor2zz08ukh6"},{"title":"k近邻法-统计学习方法笔记（二）","date":"2015-11-05T10:34:36.000Z","_content":"\n##算法介绍\nk近邻法（KNN）是一种常用的机器学习方法，可用于分类，也可用于回归。对于分类，简单来讲就是对于待分类点找出与之最邻近的k个，根据这k个的类比以一定规则决定这个点的类别，一般用的是选举的策略。回归的话基本一致，只是最后取值规则修改下，可以采用平均值或者加权平均值。\n通过上面的简介，可以看出来k近邻法有以下三个基本要素：\n1. k值的选择。当k较大时，可以假设当k为样本容量N时，就是求均值，模型过于简单了。如果k太小，极端情况下k取1，那么很容易被噪声干扰，本质上是k太小，导致模型过于复杂，出现了过拟合。\n2. 距离的度量。常用的欧式距离，还有曼哈顿距离，更为普遍的是Minkowski距离。\n3. 分类决策规则。分类一般是少数服从多数，回归的话取均值或者按距离加权均值，距离越近权值越大。\n\n##kd树\n对于给定样本点，当要查找预测点的k近邻时，可以直接遍历样本，选出最近的k个即可。但是这样每次都要遍历样本，当样本规模较大时，效率太低了。于是提出了KD树（k dimension tree）算法，kd数可以看作是多维度下的二叉排序树。对于一维的情况，就是平时所见的二叉排序树。当多维时，每次选取其中一维进行分割。至于选那一维，可以选方差最大的维度，方差越大说明数据分布越散，越容易分割。kd树生成算法描述如下：\n**算法：构建k-d树（createKDTree）**\n**输入：数据点集Data-set和其所在的空间Range**\n**输出：Kd，类型为k-d tree**\n1. If Data-set为空，则返回空的k-d tree\n2. 调用节点生成程序：\n　　（1）确定split域：对于所有描述子数据（特征矢量），统计它们在每个维上的数据方差。以SURF特征为例，描述子为64维，可计算64个方差。挑选出最大值，对应的维就是split域的值。数据方差大表明沿该坐标轴方向上的数据分散得比较开，在这个方向上进行数据分割有较好的分辨率；\n　　（2）确定Node-data域：数据点集Data-set按其第split域的值排序。位于正中间的那个数据点被选为Node-data。此时新的Data-set' = Data-set\\Node-data（除去其中Node-data这一点）。|\n3. dataleft = {d属于Data-set' && d[split] ≤ Node-data[split]}\n   Left_Range = {Range && dataleft}\n   dataright = {d属于Data-set' && d[split] > Node-data[split]}\n   Right_Range = {Range && dataright}|\n4. left = 由（dataleft，Left_Range）建立的k-d tree，即递归调用createKDTree（dataleft，Left_\n   Range）。并设置left的parent域为Kd；\n   right = 由（dataright，Right_Range）建立的k-d tree，即调用createKDTree（dataleft，Left_\n   Range）。并设置right的parent域为Kd。\n   \n###kd树结构\n```\nclass Node:\n    def __init__(self, point, split):\n        self.left = None               #左子树\n        self.right = None              #右子树\n        self.point = point             #分割点\n        self.split = split             #分割维度\n```\n\n###kd树构造\n```\n#中位数\ndef median(lst):\n    if len(lst) % 2:\n        return np.median(lst)\n    return np.median(lst[1:])\n\n\n#欧氏距离\ndef os_distance(v1, v2):\n    return np.linalg.norm(np.array(v1) - np.array(v2))\n\n\ndef build_kdtree(points, d):\n    if len(points) == 0:\n        return None\n\n    mid = median(np.array(points[:, d]))\n    left_points = np.array([m for m in points if m[d] < mid])\n    right_points = np.array([m for m in points if m[d] > mid])\n    points = np.array([m for m in points if m[d] == mid])\n\n    n = Node(points[0], d)\n    n.left = build_kdtree(np.concatenate((left_points.reshape((len(left_points), len(points[0]))), points[1:])),\n                          (d+1) % len(points[0]))\n    n.right = build_kdtree(right_points, (d+1) % len(points[0]))\n    return n\n```\n\n###kd树查找（最近邻）\n```\ndef search_nearest(kd_tree, target):\n    if not kd_tree:\n        return None\n    search_path = []\n    nearest = kd_tree.point\n\n    #构造查找路劲\n    while kd_tree:\n        search_path.append(kd_tree)\n        if os_distance(target, nearest) > os_distance(target, kd_tree.point):\n            nearest = kd_tree.point\n        if target[kd_tree.split] < kd_tree.point[kd_tree.split]:\n            kd_tree = kd_tree.left\n        else:\n            kd_tree = kd_tree.right\n    #回溯查找\n    while search_path:\n        tree = search_path.pop()\n        if abs(target[tree.split] - tree.point[tree.split]) < os_distance(target, nearest):\n            if target[tree.split] < tree.point[tree.split]:\n                to_add = tree.right\n            else:\n                to_add = tree.left\n        if to_add:\n            search_path.append(to_add)\n        if os_distance(target, nearest) > os_distance(target, tree.point):\n            nearest = tree.point\n    return nearest\n```\n\n##总结\nk近邻法要掌握它的三要素，算法部分是kd树，kd树设计到很多知识，包括kd树的增删改查，kd树的改进。k近邻法在分类领域是一个基本的常用算法，上次做kaggle的手写字体识别，knn准确率最高，达到了0.97左右。\n \n","source":"_posts/k近邻法-统计学习方法笔记（二）.md","raw":"title: \"k近邻法-统计学习方法笔记（二）\"\ndate: 2015-11-05 18:34:36\ntags: [机器学习]\n---\n\n##算法介绍\nk近邻法（KNN）是一种常用的机器学习方法，可用于分类，也可用于回归。对于分类，简单来讲就是对于待分类点找出与之最邻近的k个，根据这k个的类比以一定规则决定这个点的类别，一般用的是选举的策略。回归的话基本一致，只是最后取值规则修改下，可以采用平均值或者加权平均值。\n通过上面的简介，可以看出来k近邻法有以下三个基本要素：\n1. k值的选择。当k较大时，可以假设当k为样本容量N时，就是求均值，模型过于简单了。如果k太小，极端情况下k取1，那么很容易被噪声干扰，本质上是k太小，导致模型过于复杂，出现了过拟合。\n2. 距离的度量。常用的欧式距离，还有曼哈顿距离，更为普遍的是Minkowski距离。\n3. 分类决策规则。分类一般是少数服从多数，回归的话取均值或者按距离加权均值，距离越近权值越大。\n\n##kd树\n对于给定样本点，当要查找预测点的k近邻时，可以直接遍历样本，选出最近的k个即可。但是这样每次都要遍历样本，当样本规模较大时，效率太低了。于是提出了KD树（k dimension tree）算法，kd数可以看作是多维度下的二叉排序树。对于一维的情况，就是平时所见的二叉排序树。当多维时，每次选取其中一维进行分割。至于选那一维，可以选方差最大的维度，方差越大说明数据分布越散，越容易分割。kd树生成算法描述如下：\n**算法：构建k-d树（createKDTree）**\n**输入：数据点集Data-set和其所在的空间Range**\n**输出：Kd，类型为k-d tree**\n1. If Data-set为空，则返回空的k-d tree\n2. 调用节点生成程序：\n　　（1）确定split域：对于所有描述子数据（特征矢量），统计它们在每个维上的数据方差。以SURF特征为例，描述子为64维，可计算64个方差。挑选出最大值，对应的维就是split域的值。数据方差大表明沿该坐标轴方向上的数据分散得比较开，在这个方向上进行数据分割有较好的分辨率；\n　　（2）确定Node-data域：数据点集Data-set按其第split域的值排序。位于正中间的那个数据点被选为Node-data。此时新的Data-set' = Data-set\\Node-data（除去其中Node-data这一点）。|\n3. dataleft = {d属于Data-set' && d[split] ≤ Node-data[split]}\n   Left_Range = {Range && dataleft}\n   dataright = {d属于Data-set' && d[split] > Node-data[split]}\n   Right_Range = {Range && dataright}|\n4. left = 由（dataleft，Left_Range）建立的k-d tree，即递归调用createKDTree（dataleft，Left_\n   Range）。并设置left的parent域为Kd；\n   right = 由（dataright，Right_Range）建立的k-d tree，即调用createKDTree（dataleft，Left_\n   Range）。并设置right的parent域为Kd。\n   \n###kd树结构\n```\nclass Node:\n    def __init__(self, point, split):\n        self.left = None               #左子树\n        self.right = None              #右子树\n        self.point = point             #分割点\n        self.split = split             #分割维度\n```\n\n###kd树构造\n```\n#中位数\ndef median(lst):\n    if len(lst) % 2:\n        return np.median(lst)\n    return np.median(lst[1:])\n\n\n#欧氏距离\ndef os_distance(v1, v2):\n    return np.linalg.norm(np.array(v1) - np.array(v2))\n\n\ndef build_kdtree(points, d):\n    if len(points) == 0:\n        return None\n\n    mid = median(np.array(points[:, d]))\n    left_points = np.array([m for m in points if m[d] < mid])\n    right_points = np.array([m for m in points if m[d] > mid])\n    points = np.array([m for m in points if m[d] == mid])\n\n    n = Node(points[0], d)\n    n.left = build_kdtree(np.concatenate((left_points.reshape((len(left_points), len(points[0]))), points[1:])),\n                          (d+1) % len(points[0]))\n    n.right = build_kdtree(right_points, (d+1) % len(points[0]))\n    return n\n```\n\n###kd树查找（最近邻）\n```\ndef search_nearest(kd_tree, target):\n    if not kd_tree:\n        return None\n    search_path = []\n    nearest = kd_tree.point\n\n    #构造查找路劲\n    while kd_tree:\n        search_path.append(kd_tree)\n        if os_distance(target, nearest) > os_distance(target, kd_tree.point):\n            nearest = kd_tree.point\n        if target[kd_tree.split] < kd_tree.point[kd_tree.split]:\n            kd_tree = kd_tree.left\n        else:\n            kd_tree = kd_tree.right\n    #回溯查找\n    while search_path:\n        tree = search_path.pop()\n        if abs(target[tree.split] - tree.point[tree.split]) < os_distance(target, nearest):\n            if target[tree.split] < tree.point[tree.split]:\n                to_add = tree.right\n            else:\n                to_add = tree.left\n        if to_add:\n            search_path.append(to_add)\n        if os_distance(target, nearest) > os_distance(target, tree.point):\n            nearest = tree.point\n    return nearest\n```\n\n##总结\nk近邻法要掌握它的三要素，算法部分是kd树，kd树设计到很多知识，包括kd树的增删改查，kd树的改进。k近邻法在分类领域是一个基本的常用算法，上次做kaggle的手写字体识别，knn准确率最高，达到了0.97左右。\n \n","slug":"k近邻法-统计学习方法笔记（二）","published":1,"updated":"2015-11-05T13:39:42.344Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq9o9r6i000qtor2d02jnp4b"},{"title":"kaggle digit recognizer之naive bayes解法","date":"2015-09-28T09:58:36.000Z","_content":"\n##naive bayes\nnaive bayes(朴素贝叶斯)是一种常见的分类算法，原理就是概率论一开始讲的贝叶斯原理。之所以naive，是因为它有个很关键的假设：各个特征之间是无关联的。这是一种理想化的假设，所以如果特征之间关联比较密切，就不适合了。朴素贝叶斯在文本分类应用广泛，如分词，垃圾邮件识别等。至于做手写图片识别，其实是不太合适的，因为图片的像素之间关联还是挺大的，但是作为初步学习该方法，还是尝试了下，结果确实不怎么样，不到0.6的正确率，网上看有用朴素贝叶斯达到0.8的，应该是在哪方面做优化了。关于朴素贝叶斯方法的详细介绍，可以看下面参考1的链接，讲的很详细直观。\n\n##实现\nR的e1071包有naiveBayes方法，但是使用该方法要注意，label一定得是factor类型的，函数文档也说了，只能做离散值的预测，如果是数字它会认为是连续的。所以可以看到代码中对label做了类型转换。关于该函数的参考文档，可以参考2的链接。\n\n##代码\n```\ntrain <- read.csv(\"data/train.csv\", header=TRUE)\ntest <- read.csv(\"data/test.csv\", header=TRUE)\n\n#注意要对label做类型转换，使用拉普拉斯平滑处理\nclassifier <- naiveBayes(as.factor(label) ~ ., train, laplace = 10)\nresult <- predict(classifier, test)\n\n#这个地方很奇怪，写入文件时result都+1了，所以提前-1，还没找到是什么原因\nresult.table <- data.frame(ImageId=1:nrow(test), Label=as.numeric(result) - 1)\nwrite.csv(result.table, \"result/naive_bayes.csv\", row.names = F)\n```\n\n##心得\n朴素贝叶斯算法算是比较简单了，其实之前用的pca、knn、logistic regression、以及线性回归都是非常直观的算法，可能公式推导有的比较复杂。最近也算是了解了它们，然后使用已有的库做练习。后续再熟悉下svm、神经网络，然后就用R或者其他语言实现一遍，还有它们的mapreduce版本也尝试实现下，然后就是能自己用尽可能简单的语言将这些算法尽可能清晰地描述出来。这么一看，任务还是挺多滴。加油！\n\n##参考\n1. [朴素贝叶斯](http://www.cnblogs.com/leoo2sk/archive/2010/09/17/naive-bayesian-classifier.html)\n2. [R naiveBayes](http://www.inside-r.org/packages/cran/e1071/docs/naiveBayes)\n","source":"_posts/kaggle-digit-recognizer之naive-bayes解法.md","raw":"title: \"kaggle digit recognizer之naive bayes解法\"\ndate: 2015-09-28 17:58:36\ntags: [kaggle, 机器学习]\n---\n\n##naive bayes\nnaive bayes(朴素贝叶斯)是一种常见的分类算法，原理就是概率论一开始讲的贝叶斯原理。之所以naive，是因为它有个很关键的假设：各个特征之间是无关联的。这是一种理想化的假设，所以如果特征之间关联比较密切，就不适合了。朴素贝叶斯在文本分类应用广泛，如分词，垃圾邮件识别等。至于做手写图片识别，其实是不太合适的，因为图片的像素之间关联还是挺大的，但是作为初步学习该方法，还是尝试了下，结果确实不怎么样，不到0.6的正确率，网上看有用朴素贝叶斯达到0.8的，应该是在哪方面做优化了。关于朴素贝叶斯方法的详细介绍，可以看下面参考1的链接，讲的很详细直观。\n\n##实现\nR的e1071包有naiveBayes方法，但是使用该方法要注意，label一定得是factor类型的，函数文档也说了，只能做离散值的预测，如果是数字它会认为是连续的。所以可以看到代码中对label做了类型转换。关于该函数的参考文档，可以参考2的链接。\n\n##代码\n```\ntrain <- read.csv(\"data/train.csv\", header=TRUE)\ntest <- read.csv(\"data/test.csv\", header=TRUE)\n\n#注意要对label做类型转换，使用拉普拉斯平滑处理\nclassifier <- naiveBayes(as.factor(label) ~ ., train, laplace = 10)\nresult <- predict(classifier, test)\n\n#这个地方很奇怪，写入文件时result都+1了，所以提前-1，还没找到是什么原因\nresult.table <- data.frame(ImageId=1:nrow(test), Label=as.numeric(result) - 1)\nwrite.csv(result.table, \"result/naive_bayes.csv\", row.names = F)\n```\n\n##心得\n朴素贝叶斯算法算是比较简单了，其实之前用的pca、knn、logistic regression、以及线性回归都是非常直观的算法，可能公式推导有的比较复杂。最近也算是了解了它们，然后使用已有的库做练习。后续再熟悉下svm、神经网络，然后就用R或者其他语言实现一遍，还有它们的mapreduce版本也尝试实现下，然后就是能自己用尽可能简单的语言将这些算法尽可能清晰地描述出来。这么一看，任务还是挺多滴。加油！\n\n##参考\n1. [朴素贝叶斯](http://www.cnblogs.com/leoo2sk/archive/2010/09/17/naive-bayesian-classifier.html)\n2. [R naiveBayes](http://www.inside-r.org/packages/cran/e1071/docs/naiveBayes)\n","slug":"kaggle-digit-recognizer之naive-bayes解法","published":1,"updated":"2015-11-13T12:51:33.591Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq9o9r6k000stor25kkm3nks"},{"title":"kaggle digit recognizer之logistic regression解法","date":"2015-09-23T10:16:02.000Z","_content":"\n## logistic regression ##\n>**逻辑回归**是一种常用的分类算法（虽然名称带着回归，其实是分类），在广告行业中运用非常广泛，主要用来判断用户是否点击某个广告，以此实现广告的最佳投放效果。逻辑回归一般用来解决二分类的问题，即某件事情只有两种可能，通过训练数据得到预测数据发生某种情况的可能性，一般如果大于0.5我们认为该事件会发生，小于0.5则该事件的互斥事件会发生。\n\n## 本题思路 ##\n由于数字有10种可能，所以这是一种多分类的场景。逻辑回归在这种场景下的一般做法是：如果有n种分类，则做n次逻辑回归，每次把是该种类的视为一类，把非该种类的视为另一类，这样可以计算出n个可能性，取可能性最大的作为分类。针对本题我也是这么做的，但是效果非常不理想，正确率仅为0.80（tnn的还运行了好几个小时）。但是作为通过这次练习，大致熟悉了逻辑回归。\n\n## 代码 ##\n\n```\ntrain <- read.csv(\"data/train.csv\", header=TRUE)\ntest <- read.csv(\"data/test.csv\", header=TRUE)\n\nlabels <- train[,1]\ntrain <- train[,-1]\n\n#create formula\nxnam <- paste0(\"pixel\", c(0:783))\nformula <- as.formula(paste(\"lr.labels ~ \", paste(xnam, collapse = \"+\")))\n\npre <- list()\nfor (i in 0 : 9) {\n    lr.labels <- ifelse(labels == i, 1, 0)\n    logic.fit <- glm(formula = formula, data = cbind(lr.labels, train), family=binomial(link=\"logit\"))\n    p <- predict(logic.fit, test)\n    pre <- cbind(pre, exp(p) / 1 + exp(p))\n}\n\nresult <- max.col(pre) - 1\n```\n\n## 说明 ##\nglm是R广义线性模型函数，可以处理很多种回归，通过family参数控制回归类型，主要有：\n1. binomal(link='logit')         ----响应变量服从二项分布，连接函数为logit，即logistic回归\n2. binomal(link='probit')       ----响应变量服从二项分布，连接函数为probit\n3. poisson(link='identity')     ----响应变量服从泊松分布，即泊松回归\n\n还有是对R的formula不熟悉，最后参考[这里](http://site.douban.com/182577/widget/notes/10567181/note/318916395/)算是理解了吧。\n\n## 参考 ##\n1. [逻辑回归](http://blog.csdn.net/pakko/article/details/37878837)\n1. [R广义线性模型](http://www.cnblogs.com/runner-ljt/p/4574275.html)\n2. [R中的formula与Formula](http://site.douban.com/182577/widget/notes/10567181/note/318916395/)\n\n\n","source":"_posts/kaggle-digit-recognizer之logistic-regression解法.md","raw":"title: \"kaggle digit recognizer之logistic regression解法\"\ndate: 2015-09-23 18:16:02\ntags: [kaggle, 机器学习]\n---\n\n## logistic regression ##\n>**逻辑回归**是一种常用的分类算法（虽然名称带着回归，其实是分类），在广告行业中运用非常广泛，主要用来判断用户是否点击某个广告，以此实现广告的最佳投放效果。逻辑回归一般用来解决二分类的问题，即某件事情只有两种可能，通过训练数据得到预测数据发生某种情况的可能性，一般如果大于0.5我们认为该事件会发生，小于0.5则该事件的互斥事件会发生。\n\n## 本题思路 ##\n由于数字有10种可能，所以这是一种多分类的场景。逻辑回归在这种场景下的一般做法是：如果有n种分类，则做n次逻辑回归，每次把是该种类的视为一类，把非该种类的视为另一类，这样可以计算出n个可能性，取可能性最大的作为分类。针对本题我也是这么做的，但是效果非常不理想，正确率仅为0.80（tnn的还运行了好几个小时）。但是作为通过这次练习，大致熟悉了逻辑回归。\n\n## 代码 ##\n\n```\ntrain <- read.csv(\"data/train.csv\", header=TRUE)\ntest <- read.csv(\"data/test.csv\", header=TRUE)\n\nlabels <- train[,1]\ntrain <- train[,-1]\n\n#create formula\nxnam <- paste0(\"pixel\", c(0:783))\nformula <- as.formula(paste(\"lr.labels ~ \", paste(xnam, collapse = \"+\")))\n\npre <- list()\nfor (i in 0 : 9) {\n    lr.labels <- ifelse(labels == i, 1, 0)\n    logic.fit <- glm(formula = formula, data = cbind(lr.labels, train), family=binomial(link=\"logit\"))\n    p <- predict(logic.fit, test)\n    pre <- cbind(pre, exp(p) / 1 + exp(p))\n}\n\nresult <- max.col(pre) - 1\n```\n\n## 说明 ##\nglm是R广义线性模型函数，可以处理很多种回归，通过family参数控制回归类型，主要有：\n1. binomal(link='logit')         ----响应变量服从二项分布，连接函数为logit，即logistic回归\n2. binomal(link='probit')       ----响应变量服从二项分布，连接函数为probit\n3. poisson(link='identity')     ----响应变量服从泊松分布，即泊松回归\n\n还有是对R的formula不熟悉，最后参考[这里](http://site.douban.com/182577/widget/notes/10567181/note/318916395/)算是理解了吧。\n\n## 参考 ##\n1. [逻辑回归](http://blog.csdn.net/pakko/article/details/37878837)\n1. [R广义线性模型](http://www.cnblogs.com/runner-ljt/p/4574275.html)\n2. [R中的formula与Formula](http://site.douban.com/182577/widget/notes/10567181/note/318916395/)\n\n\n","slug":"kaggle-digit-recognizer之logistic-regression解法","published":1,"updated":"2015-11-13T12:51:33.590Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq9o9r6n000wtor2gz2or8sj"},{"title":"kaggle digit recognizer之PCA+KNN解法","date":"2015-09-16T03:45:27.000Z","_content":"\n## 背景 ##\n\t    一直想通过比赛练习什么的加强对机器学习算法的理解（工作都没用到什么机器学习算法），最近发现[kaggele](https://www.kaggle.com/)是一个不错网站。就找了上面一道名Digit Recognizer习题练手，借鉴多方观点，决定先尝试pca+knn方法（主要是我觉得比较简单利于理解）。以后再试试逻辑回归、SVM、贝叶斯、deep learning吧。\n\n## 思路 ##\n\t    思路其实很简单了，KNN是一个比较容易理解的分类算法。它的原理说起来也很简单，就是待分类数据的k个已经分好类的邻居，k个邻居中出现最多的就作为它的分类了。其实knn也可以用来做回归，只是不采用投票的方式，而是取k个邻居的均值，更准确点是按距离加权的中值。那么怎么衡量两个数据间的距离呢，算法有很多种，最常用的就是欧式距离拉.那么回到本题，每个图片其实是由28*28个像素组成，即数据的维度是784，如果直接上knn，由于维度太大，计算量也相当高了。目测普通单个机器得个一天吧。那么就可以使用到pca降维了。我选择pca降维度降到64，单机下几分钟就出结果了。提交几次终于成功了，正确率0.97186，二百多名，好开森，知足常乐，哈哈。代码就很简单了，下面贴出来：\n\n## 代码 ##\n\n```\nlibrary(class)\n\ntrain <- read.csv(\"train.csv\", header=TRUE)\ntest <- read.csv(\"test.csv\", header=TRUE)\n\ntrain <- as.matrix(train)\ntest <- as.matrix(test)\n\nlabels <- as.numeric(train[,1])\ntrain <- train[,-1]\n\nall <- rbind(train, test)\n\n//计算主成分\npca <- princomp(all)\n\n//对训练数据降维转换\ntrain <- train %*% pca$loadings[,1:64]\n//对测试数据降维转换\ntest <- test %*% pca$loadings[,1:64]\n\n//pre即是最终结果\npre <- knn(train, test, labels, 9)\t\n```\n\n## 细节 ##\n\t第一次直接提交，报错了，格式错误。试题明明写的每行只需写出结果就行。搜了下才发现提交的结果要是csv格式的。第一行为固定标题，然后是数据，第一列id，第二列识别结果，id从1递增。比如：\n\tImageId,Label\n\t1,2\n\t2,0\n\t3,9\n\t4,9\n\t...\n\n## 排名截图 ##\n![](/images/kaggle_first.png)\n\n----------\n","source":"_posts/kaggle-digit-recognizer之PCA+KNN解法.md","raw":"title: \"kaggle digit recognizer之PCA+KNN解法\"\ndate: 2015-09-16 11:45:27\ntags: [kaggle, 机器学习]\n---\n\n## 背景 ##\n\t    一直想通过比赛练习什么的加强对机器学习算法的理解（工作都没用到什么机器学习算法），最近发现[kaggele](https://www.kaggle.com/)是一个不错网站。就找了上面一道名Digit Recognizer习题练手，借鉴多方观点，决定先尝试pca+knn方法（主要是我觉得比较简单利于理解）。以后再试试逻辑回归、SVM、贝叶斯、deep learning吧。\n\n## 思路 ##\n\t    思路其实很简单了，KNN是一个比较容易理解的分类算法。它的原理说起来也很简单，就是待分类数据的k个已经分好类的邻居，k个邻居中出现最多的就作为它的分类了。其实knn也可以用来做回归，只是不采用投票的方式，而是取k个邻居的均值，更准确点是按距离加权的中值。那么怎么衡量两个数据间的距离呢，算法有很多种，最常用的就是欧式距离拉.那么回到本题，每个图片其实是由28*28个像素组成，即数据的维度是784，如果直接上knn，由于维度太大，计算量也相当高了。目测普通单个机器得个一天吧。那么就可以使用到pca降维了。我选择pca降维度降到64，单机下几分钟就出结果了。提交几次终于成功了，正确率0.97186，二百多名，好开森，知足常乐，哈哈。代码就很简单了，下面贴出来：\n\n## 代码 ##\n\n```\nlibrary(class)\n\ntrain <- read.csv(\"train.csv\", header=TRUE)\ntest <- read.csv(\"test.csv\", header=TRUE)\n\ntrain <- as.matrix(train)\ntest <- as.matrix(test)\n\nlabels <- as.numeric(train[,1])\ntrain <- train[,-1]\n\nall <- rbind(train, test)\n\n//计算主成分\npca <- princomp(all)\n\n//对训练数据降维转换\ntrain <- train %*% pca$loadings[,1:64]\n//对测试数据降维转换\ntest <- test %*% pca$loadings[,1:64]\n\n//pre即是最终结果\npre <- knn(train, test, labels, 9)\t\n```\n\n## 细节 ##\n\t第一次直接提交，报错了，格式错误。试题明明写的每行只需写出结果就行。搜了下才发现提交的结果要是csv格式的。第一行为固定标题，然后是数据，第一列id，第二列识别结果，id从1递增。比如：\n\tImageId,Label\n\t1,2\n\t2,0\n\t3,9\n\t4,9\n\t...\n\n## 排名截图 ##\n![](/images/kaggle_first.png)\n\n----------\n","slug":"kaggle-digit-recognizer之PCA+KNN解法","published":1,"updated":"2015-11-13T12:51:33.589Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq9o9r6p000ztor2d0919evg"},{"title":"hive udf使用","date":"2015-09-24T10:21:35.000Z","_content":"\nhive以udf的方式提供了扩展hive的方法。每个udf只需要继承hive指定的类，通过固定的方法名识别出提供的方法。工作中经常遇到这种场景：计算周累计或者月累计。计算的逻辑是判断今天与昨天是否属于同一个周（月），如果是，结果为昨天结果加上今天的结果，否则结果为今天的结果。用hql如下：\n```sql\nCASE WHEN WEEKOFYEAR('${TIME}')= WEEKOFYEAR('${BEFORETIME}') AND F1.LOGIN_YN = 'Y' THEN\n    COALESCE(F2.WK_DAY_CNT,0) + 1\nWHEN WEEKOFYEAR('${TIME}')= WEEKOFYEAR('${BEFORETIME}') THEN COALESCE(F2.WK_DAY_CNT,0) \n    WHEN F1.LOGIN_YN = 'Y' THEN 1 ELSE 0 END)\n```\n现在我想把这段代码用一个udf实现:\n```\n    week_acc([time], [beforeTime], value, accValue)\n```\n---\n现在开始动手实现：\n1. 新建maven工程，pom文件添加hive的开发工具包以来以及joda依赖：\n```\n<dependency>\n      <groupId>org.apache.hive</groupId>\n      <artifactId>hive-pdk</artifactId>\n      <version>0.10.0</version>\n    </dependency>\n    <dependency>\n      <groupId>org.apache.hadoop</groupId>\n      <artifactId>hadoop-core</artifactId>\n      <version>1.2.1</version>\n    </dependency>\n    <dependency>\n      <groupId>joda-time</groupId>\n      <artifactId>joda-time</artifactId>\n      <version>2.8.2</version>\n    </dependency>\n```\n2. 编写自定义的udf类，继承UDF类\n```\npublic abstract class WeekAccumulator extends UDF {\n\n    public LongWritable evaluate(Text timeStr,\n                                 Text beforeTimeStr,\n                                 LongWritable todayValue,\n                                 LongWritable beforeAccumulator) {\n        return inSamePeriod(timeStr, beforeTimeStr) ?\n                new LongWritable(todayValue.get() + beforeAccumulator.get()) : todayValue;\n    }\n\n    public LongWritable evaluate(LongWritable todayValue, LongWritable beforeAccumulator) {\n        DateTime dateTime = new DateTime();\n        Text timeStr = new Text(dateTime.toString(\"yyyy-MM-dd\"));\n        Text beforeTimeStr = new Text(dateTime.minusDays(1).toString(\"yyyy-MM-dd\"));\n        return evaluate(timeStr, beforeTimeStr, todayValue, beforeAccumulator);\n    }\n\n    private boolean inSamePeriod(Text timeStr, Text beforeTimeStr) {\n        DateTime thisDate = new DateTime(timeStr.toString());\n        DateTime beforeDate = new DateTime(beforeTimeStr.toString());\n        return thisDate.getWeekOfWeekyear() == beforeDate.getWeekOfWeekyear();\n    }\n}\n```\n3.打包（注意要把依赖的jar包也打进jar包里，否则运行时会找不到依赖的jar包。）\n4. 将jar包copy到hdfs中\n5. 编辑hive conf文件夹下的.hiverc文件(没有手动创建),文件内容：\n```\nadd jar hdfs://{MASTER}/{udf path}\ncreate temporary function week_acc as '{class}';\n```\n---\n\n**打开hive cli，输入:**\n```select week_acc('2015-09-14', '2015-09-13', 1, 10)```\n**执行成功，那么udf就完成了。**\n\n## 注意事项 ##\n如果hive设置hive.exec.mode.local.auto（默认false）为true的话，上面命令会执行失败，提示jar文件找不到。只能把这个配置改成false了。\n","source":"_posts/hive-udf使用.md","raw":"title: \"hive udf使用\"\ndate: 2015-09-24 18:21:35\ntags: hive\n---\n\nhive以udf的方式提供了扩展hive的方法。每个udf只需要继承hive指定的类，通过固定的方法名识别出提供的方法。工作中经常遇到这种场景：计算周累计或者月累计。计算的逻辑是判断今天与昨天是否属于同一个周（月），如果是，结果为昨天结果加上今天的结果，否则结果为今天的结果。用hql如下：\n```sql\nCASE WHEN WEEKOFYEAR('${TIME}')= WEEKOFYEAR('${BEFORETIME}') AND F1.LOGIN_YN = 'Y' THEN\n    COALESCE(F2.WK_DAY_CNT,0) + 1\nWHEN WEEKOFYEAR('${TIME}')= WEEKOFYEAR('${BEFORETIME}') THEN COALESCE(F2.WK_DAY_CNT,0) \n    WHEN F1.LOGIN_YN = 'Y' THEN 1 ELSE 0 END)\n```\n现在我想把这段代码用一个udf实现:\n```\n    week_acc([time], [beforeTime], value, accValue)\n```\n---\n现在开始动手实现：\n1. 新建maven工程，pom文件添加hive的开发工具包以来以及joda依赖：\n```\n<dependency>\n      <groupId>org.apache.hive</groupId>\n      <artifactId>hive-pdk</artifactId>\n      <version>0.10.0</version>\n    </dependency>\n    <dependency>\n      <groupId>org.apache.hadoop</groupId>\n      <artifactId>hadoop-core</artifactId>\n      <version>1.2.1</version>\n    </dependency>\n    <dependency>\n      <groupId>joda-time</groupId>\n      <artifactId>joda-time</artifactId>\n      <version>2.8.2</version>\n    </dependency>\n```\n2. 编写自定义的udf类，继承UDF类\n```\npublic abstract class WeekAccumulator extends UDF {\n\n    public LongWritable evaluate(Text timeStr,\n                                 Text beforeTimeStr,\n                                 LongWritable todayValue,\n                                 LongWritable beforeAccumulator) {\n        return inSamePeriod(timeStr, beforeTimeStr) ?\n                new LongWritable(todayValue.get() + beforeAccumulator.get()) : todayValue;\n    }\n\n    public LongWritable evaluate(LongWritable todayValue, LongWritable beforeAccumulator) {\n        DateTime dateTime = new DateTime();\n        Text timeStr = new Text(dateTime.toString(\"yyyy-MM-dd\"));\n        Text beforeTimeStr = new Text(dateTime.minusDays(1).toString(\"yyyy-MM-dd\"));\n        return evaluate(timeStr, beforeTimeStr, todayValue, beforeAccumulator);\n    }\n\n    private boolean inSamePeriod(Text timeStr, Text beforeTimeStr) {\n        DateTime thisDate = new DateTime(timeStr.toString());\n        DateTime beforeDate = new DateTime(beforeTimeStr.toString());\n        return thisDate.getWeekOfWeekyear() == beforeDate.getWeekOfWeekyear();\n    }\n}\n```\n3.打包（注意要把依赖的jar包也打进jar包里，否则运行时会找不到依赖的jar包。）\n4. 将jar包copy到hdfs中\n5. 编辑hive conf文件夹下的.hiverc文件(没有手动创建),文件内容：\n```\nadd jar hdfs://{MASTER}/{udf path}\ncreate temporary function week_acc as '{class}';\n```\n---\n\n**打开hive cli，输入:**\n```select week_acc('2015-09-14', '2015-09-13', 1, 10)```\n**执行成功，那么udf就完成了。**\n\n## 注意事项 ##\n如果hive设置hive.exec.mode.local.auto（默认false）为true的话，上面命令会执行失败，提示jar文件找不到。只能把这个配置改成false了。\n","slug":"hive-udf使用","published":1,"updated":"2015-12-01T13:29:46.808Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciq9o9r6s0012tor2wqep3yfz"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ciq9o9r5t0007tor2664msty6","tag_id":"ciq9o9r5w0008tor2e9vsglln","_id":"ciq9o9r5z0009tor2vzkilkhw"},{"post_id":"ciq9o9r62000btor2kp7i1wom","tag_id":"ciq9o9r63000ctor2ik68wxyw","_id":"ciq9o9r64000dtor2rn3wo65m"},{"post_id":"ciq9o9r65000etor2qq6md0tt","tag_id":"ciq9o9r67000ftor2a861yq19","_id":"ciq9o9r67000gtor2tamanzc7"},{"post_id":"ciq9o9r68000htor2u8eg3cg3","tag_id":"ciq9o9r5w0008tor2e9vsglln","_id":"ciq9o9r69000itor29rrjqt0g"},{"post_id":"ciq9o9r6a000jtor24e5rympa","tag_id":"ciq9o9r6b000ktor2xcacrdy0","_id":"ciq9o9r6b000ltor2kug80pi0"},{"post_id":"ciq9o9r6c000mtor2kcrwjlpb","tag_id":"ciq9o9r5w0008tor2e9vsglln","_id":"ciq9o9r6d000ntor2zix18xf9"},{"post_id":"ciq9o9r6e000otor2zz08ukh6","tag_id":"ciq9o9r67000ftor2a861yq19","_id":"ciq9o9r6h000ptor29ns0msep"},{"post_id":"ciq9o9r6i000qtor2d02jnp4b","tag_id":"ciq9o9r63000ctor2ik68wxyw","_id":"ciq9o9r6j000rtor2k7ysyv0d"},{"post_id":"ciq9o9r6k000stor25kkm3nks","tag_id":"ciq9o9r6l000ttor223i0arfx","_id":"ciq9o9r6m000utor2qe6h0fbk"},{"post_id":"ciq9o9r6k000stor25kkm3nks","tag_id":"ciq9o9r63000ctor2ik68wxyw","_id":"ciq9o9r6m000vtor20i9gcvlh"},{"post_id":"ciq9o9r6n000wtor2gz2or8sj","tag_id":"ciq9o9r6l000ttor223i0arfx","_id":"ciq9o9r6o000xtor2ogay1z0o"},{"post_id":"ciq9o9r6n000wtor2gz2or8sj","tag_id":"ciq9o9r63000ctor2ik68wxyw","_id":"ciq9o9r6o000ytor2g1tqywdk"},{"post_id":"ciq9o9r6p000ztor2d0919evg","tag_id":"ciq9o9r6l000ttor223i0arfx","_id":"ciq9o9r6r0010tor20y2f7h1i"},{"post_id":"ciq9o9r6p000ztor2d0919evg","tag_id":"ciq9o9r63000ctor2ik68wxyw","_id":"ciq9o9r6r0011tor24kmdzjz8"},{"post_id":"ciq9o9r6s0012tor2wqep3yfz","tag_id":"ciq9o9r6u0013tor2mdrrzjlk","_id":"ciq9o9r6v0014tor2qzeqns3m"}],"Tag":[{"name":"笔试题","_id":"ciq9o9r5w0008tor2e9vsglln"},{"name":"机器学习","_id":"ciq9o9r63000ctor2ik68wxyw"},{"name":"算法","_id":"ciq9o9r67000ftor2a861yq19"},{"name":"linux","_id":"ciq9o9r6b000ktor2xcacrdy0"},{"name":"kaggle","_id":"ciq9o9r6l000ttor223i0arfx"},{"name":"hive","_id":"ciq9o9r6u0013tor2mdrrzjlk"}]}}